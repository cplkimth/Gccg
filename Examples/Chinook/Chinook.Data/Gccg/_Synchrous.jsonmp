{
	"Version":2,
	"Scope":0,
	"TargetPath":"Synchrous.g.cs",
	"Overwritable": true
}
*** body starts here ***// <auto-generated> This file has been generated by Gccg</auto-generated>

#region usings
using System.ComponentModel;
using System.ComponentModel.DataAnnotations.Schema;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.Json.Serialization;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using Microsoft.Extensions.Logging;
#endregion

namespace `DataProjectNamespace`;

#region EntityDao<T>
public abstract partial class EntityDao<T> where T : Entity<T>, new()
{
    #region Get
    public virtual List<T> Get()
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToList();
    }

    public virtual T[] GetAsArray()
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToArray();
    }

    public virtual HashSet<T> GetAsHashSet()
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToHashSet();
    }

    public virtual Dictionary<K, T> GetAsDictionary<K>(Func<T, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToDictionary(keySelector);
    }

    public virtual Dictionary<K, E> GetAsDictionary<K, E>(Func<T, K> keySelector, Func<T, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToDictionary(keySelector, elementSelector);
    }

    public virtual List<T> Get(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToList();
    }

    public virtual T[] GetAsArray(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToArray();
    }

    public virtual HashSet<T> GetAsHashSet(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToHashSet();
    }

    public virtual Dictionary<K, T> GetAsDictionary<K>(
        Expression<Func<T, bool>> where, Func<T, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToDictionary(keySelector);
    }

    public virtual Dictionary<K, E> GetAsDictionary<K, E>(
        Expression<Func<T, bool>> where, Func<T, K> keySelector, Func<T, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToDictionary(keySelector, elementSelector);
    }

    public virtual List<T> Get<O>(Expression<Func<T, O>> orderBy, bool ascending)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(null, orderBy, ascending, 0, int.MaxValue, context).ToList();
    }

    public virtual T[] GetAsArray<O>(Expression<Func<T, O>> orderBy, bool ascending)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(null, orderBy, ascending, 0, int.MaxValue, context).ToArray();
    }

    public virtual List<T> Get<O>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(null, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
    }
    
    public virtual T[] GetAsArray<O>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(null, orderBy, ascending, startRowIndex, maximumRows, context).ToArray();
    }

    public virtual List<T> Get<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(where, orderBy, ascending, 0, int.MaxValue, context).ToList();
    }

    public virtual T[] GetAsArray<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(where, orderBy, ascending, 0, int.MaxValue, context).ToArray();
    }

    public virtual List<T> Get<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
    }
    
    public virtual T[] GetAsArray<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToArray();
    }
    #endregion Get

	#region Select
    public virtual List<S> Select<S>(Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(null, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<S>(Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(null, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToArray();
    }

    public virtual HashSet<S> SelectAsHashSet<S>(Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(null, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToHashSet();
    }

    public virtual List<S> Select<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(where, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(where, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToArray();
    }

    public virtual HashSet<S> SelectAsHashSet<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(where, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToHashSet();
    }

    public virtual List<S> Select<O, S>(Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(null, orderBy, ascending, 0, int.MaxValue, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<O, S>(Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(null, orderBy, ascending, 0, int.MaxValue, context);
        return query.Select(select).ToArray();
    }

    public virtual List<S> Select<O, S>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(null, orderBy, ascending, startRowIndex, maximumRows, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<O, S>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(null, orderBy, ascending, startRowIndex, maximumRows, context);
        return query.Select(select).ToArray();
    }

    public virtual List<S> Select<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, 0, int.MaxValue, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, 0, int.MaxValue, context);
        return query.Select(select).ToArray();
    }

    public virtual List<S> Select<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
        return query.Select(select).ToArray();
    }
	#endregion Select

	#region GetFirst / GetLast
    public virtual T GetFirst()
        => GetScalar<T>(null, null, true);

    public virtual T GetFirst(Expression<Func<T, bool>> where) 
        => GetScalar<T>(where, null, true);

    public virtual T GetFirst<O>(Expression<Func<T, O>> orderBy)
        => GetScalar<O>(null, orderBy, true);

    public virtual T GetFirst<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy)
        => GetScalar(where, orderBy, true);

	private T GetScalar<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending)
	{
        using var context = DbContextFactory.Create();

	    return GetScalarCore(where, orderBy, ascending, context).FirstOrDefault();
	}

    public virtual T GetLast<O>(Expression<Func<T, O>> orderBy)
        => GetScalar(null, orderBy, false);

    public virtual T GetLast<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy)
        => GetScalar(where, orderBy, false);
	#endregion GetFirst / GetLast

	#region SelectFirst / SelectLast
    public virtual S SelectFirst<S>(Expression<Func<T, S>> select)
        => SelectScalar<T, S>(null, null, select, false);

    public virtual S SelectFirst<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
        => SelectScalar<T, S>(where, null, select, false);

    public virtual S SelectFirst<O, S>(Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(null, orderBy, select, true);

    public virtual S SelectFirst<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(where, orderBy, select, true);

    private S SelectScalar<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select, bool ascending)
	{
        using var context = DbContextFactory.Create();

		var query = GetScalarCore(where, orderBy, ascending, context);
		return query.Select(select).FirstOrDefault();
	}

    public virtual S SelectLast<O, S>(Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(null, orderBy, select, false);

    public virtual S SelectLast<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(where, orderBy, select, false);
    #endregion SelectFirst / SelectLast

	#region GetCount
    public virtual int GetCount()
        => GetCount(null);

    public virtual int GetCount(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        var query = MakeCountQuery(where, context);
        return query.Count();
    }
	#endregion GetCount

	#region Exist
    public virtual bool Exists(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        var query = MakeCountQuery(where, context);
        return query.Any();
    }
	#endregion Exist

	#region Insert / Update / Delete
    
    internal (int Count, T Entity) SaveChanges(LogType logType, params IEnumerable<T> entities)
	{
        using var context = DbContextFactory.Create();

        foreach (var entity in entities)
    		MarkToSave(context, logType, entity);
			
		int count = context.SaveChanges();
		if (count > 0)
            foreach (var entity in entities)
    			OnSaved(entity, logType);

        return (count, count > 0 ? entities.First() : null);
	}

	public virtual T Insert(T entity)
        => (SaveChanges(LogType.Insert, entity)).Entity;

	public virtual int InsertMany(IEnumerable<T> entities)
        => (SaveChanges(LogType.Insert, entities)).Count;

	public virtual int Update(T entity) 
        => (SaveChanges(LogType.Update, entity)).Count;

	public virtual int UpdateMany(IEnumerable<T> entities) 
        => (SaveChanges(LogType.Update, entities)).Count;

	public virtual int Delete(T entity) 
        => (SaveChanges(LogType.Delete, entity)).Count;

	public virtual int DeleteMany(IEnumerable<T> entities) 
        => (SaveChanges(LogType.Delete, entities)).Count;

	public virtual int DeleteAll(Expression<Func<T, bool>> where)
	{
        using var context = DbContextFactory.Create();

		var entities = Get(where);

        return DeleteMany(entities);
	}

    public virtual T InsertIfNotExist(T entity)
    {
        using var context = DbContextFactory.Create();

        int count = context.Set<T>().Count(HasSameKey(entity));
        if (count > 0)
            return null;

        return Insert(entity);
    }

    public virtual bool InsertOrUpdate(T entity, bool withAudit = false)
    {
        using var context = DbContextFactory.Create();

        int count = context.Set<T>().Count(HasSameKey(entity));
        if (count > 0)
        {
            Update(entity);
            return false;
        }
        else
        {
            Insert(entity);
            return true;
        }
    }	
	#endregion Insert / Update / Delete

    #region ExecuteUpdate / ExecuteDelete
    public int ExecuteUpdate(Expression<Func<T, bool>> predicate, Expression<Func<SetPropertyCalls<T>, SetPropertyCalls<T>>> setPropertyCalls)
    {
        using var context = DbContextFactory.Create();

        return context.Set<T>().Where(predicate).ExecuteUpdate(setPropertyCalls);
    }

    public int ExecuteDelete(Expression<Func<T, bool>> predicate)
    {
        using var context = DbContextFactory.Create();

        return context.Set<T>().Where(predicate).ExecuteDelete();
    }
    #endregion ExecuteUpdate / ExecuteDelete
}
#endregion EntityDao<T>

`T #region `Name`Dao
/// <summary>
/// `Name` 데이터 클래스
/// </summary>
public partial class `Name`Dao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	`P:[N]:/// <param name="`name`">기본키</param>``
	/// <returns>기본키가 일치하는 엔터티</returns>
    public `Name` GetByKey(`P:, :`Type` `name` ``)
	{
        using var context = DbContextFactory.Create();

        return context.Set<`Name`>().FirstOrDefault(x => `P: && : x.`Name` == `name` ``);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	`P:[N]:/// <param name="`name`">기본키</param>``
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(`P:, :`Type` `name` ``)
	{
        using var context = DbContextFactory.Create();

		return context.Set<`Name`>().Count(x => `P: && : x.`Name` == `name` ``) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	`P::/// <param name="`name`">기본키</param> ``
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(`P:, :`Type` `name` ``)
	{
        var entity = GetByKey(`P:, :`name` ``);

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	`F::
	#region GetBy`Name`
    public List<`Table`> GetBy`Name`(`Type` `name`)
    {
        using var context = DbContextFactory.Create();

        return GetBy`Name`Core(context, `name`).ToList();
    }
    
    public `Table`[] GetBy`Name`AsArray(`Type` `name`)
    {
        using var context = DbContextFactory.Create();

        return GetBy`Name`Core(context, `name`).ToArray();
    }
    
    public HashSet<`Table`> GetBy`Name`AsHastSet(`Type` `name`)
    {
        using var context = DbContextFactory.Create();

        return GetBy`Name`Core(context, `name`).ToHashSet();
    }
    
    public Dictionary<K, `Table`> GetBy`Name`AsDictionary<K>(`Type` `name`, Func<`Table`, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetBy`Name`Core(context, `name`).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetBy`Name`AsDictionary<K, E>(`Type` `name`, Func<`Table`, K> keySelector,Func<`Table`, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetBy`Name`Core(context, `name`).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    ``

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    `P::/// <param name="`name`">기본키</param> ``
    /// <returns></returns>
    public int ExecuteDeleteByKey(`P:, :`Type` `name` ``)
        => ExecuteDelete(x => `P:&& :x.`Name` == `name` ``);

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    `P::/// <param name="`name`">기본키</param> ``
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(`P:, :`Type` `name` ``, Expression<Func<SetPropertyCalls<`Name`>, SetPropertyCalls<`Name`>>> setPropertyCalls)
        => ExecuteUpdate(x => `P:&& :x.`Name` == `name` ``, setPropertyCalls);
}
#endregion `Name`Dao
T`
