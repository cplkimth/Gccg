{
	"Version":2,
	"Scope":0,
	"TargetPath":"Data.g.cs",
	"Overwritable": true
}
*** body starts here ***// <auto-generated> This file has been generated by Gccg</auto-generated>

#region usings
using System.ComponentModel;
using System.ComponentModel.DataAnnotations.Schema;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.Json.Serialization;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using Microsoft.Extensions.Logging;
#endregion

namespace `DataProjectNamespace`;

#region IEntity
public partial interface IEntity
{
}
#endregion IEntity

#region Untyped Entity
/// <summary>
///   모든 엔터티 클래스의 부모 클래스
/// </summary>
public abstract partial class UntypedEntity : IEntity
{
	/// <summary>
	///   부가정보를 저장하기 위한 object 객체
	/// </summary>
	[NotMapped]
	[JsonIgnore]
	public object EntityTag { get; set; }

	/// <summary>
	///   모든 속성의 값을 초기화한다.string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
	/// </summary>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear()
	{
		Clear(string.Empty, DateTime.Today);
	}

	/// <summary>
	///   모든 속성의 값을 초기화한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear(DateTime defaultDateTime)
	{
		Clear(string.Empty, defaultDateTime);
	}

	/// <summary>
	///   모든 속성의 값을 초기화한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultString"> 기본 string 값 </param>
	/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear(string defaultString, DateTime defaultDateTime)
	{
		Type type = GetType();
		PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

		foreach (PropertyInfo propertyInfo in propertyInfoArray)
		{
			if (propertyInfo.CanWrite == false)
				continue;

			if (propertyInfo.PropertyType == typeof (string))
				propertyInfo.SetValue(this, defaultString, null);

			else if (propertyInfo.PropertyType == typeof (DateTime))
				propertyInfo.SetValue(this, defaultDateTime, null);
		}
	}

	/// <summary>
	///   기본키 값들을 구분자(":")로 연결하여 반환한다.
	/// </summary>
	/// <returns> </returns>
	[JsonIgnore]
	public abstract string PrimaryKeyValues {get;}

	/// <summary>
	/// 엔터티를 대표하는 문자열을 구한다.
	/// </summary>
	[JsonIgnore]
	public abstract string EntityText { get; }

	/// <summary>
	///   엔터티의 이름을 구한다.
	/// </summary>
	public abstract string GetEntityTypeName();

	partial void IsLogWritable(ref bool? logWritable);

	[JsonIgnore]
	public virtual bool LogWritable
	{
		get
		{
		bool? logWritable = null;
		IsLogWritable(ref logWritable);

		if (logWritable.HasValue)
			return logWritable.Value;

		return false;
		}
	}

	/// <summary>
	///   EntityLog에 찍힐 문자열을 구한다. Code로 끝나는 코드 프로퍼티의 경우 대응하는 문자열 프로퍼티의 값도 추가한다.
	///   주의) EntityLog 테이블의 설계 상 최대 2000자 까지만 저장할 수 있음.
	/// </summary>
	/// <returns> </returns>
	public virtual string ToEntityLog()
	{
		const int MaxLength = 2000; // 최대 2000자 까지만 저장.

		Type type = GetType();

		var propertyInfoes = type.GetProperties();

		StringBuilder builder = new StringBuilder(ToString());

		builder.AppendLine();
		foreach (var propertyInfo in propertyInfoes)
		{
			if (propertyInfo.PropertyType != typeof (int))
				continue;

			if (propertyInfo.Name.EndsWith("Code") == false)
				continue;

			string textPropertyName = propertyInfo.Name.Substring(0, propertyInfo.Name.Length - 4) + "Text";
			string textValue = GetTextFromCodeProperty(this, type, textPropertyName);

			if (textValue != null)
				builder.AppendFormat("[{0}] {1}{2}", textPropertyName, textValue, Environment.NewLine);
		}

		if (builder.Length > MaxLength)
			return builder.ToString(0, MaxLength);
		else
			return builder.ToString();
	}

	private static string GetTextFromCodeProperty(object entity, Type objectType, string textPropertyName)
	{
		var propertyInfo = objectType.GetProperty(textPropertyName);
		object propertyValue = propertyInfo.GetValue(entity, null);

		if (propertyValue is string)
			return (string) propertyValue;
		else
			return null;
	}
	
	public abstract void ClearKeyValues();
}
#endregion Untyped Entity

#region Entity<T>
/// <summary>
/// 모든 엔터티 클래스의 형이 지정된 부모 클래스
/// </summary>
/// <typeparam name="T">엔터티 클래스의 형식</typeparam>
public abstract partial class Entity<T> : UntypedEntity, IEditableObject where T : class, new()
{
	/// <summary>
	/// 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public abstract T Clone();

	#region Implementation of IEditableObject

	protected T _clone = null;

	/// <summary>
	/// IEditableObject.BeginEdit 구현
	/// </summary>
	public void BeginEdit()
	{
		if (_clone == null)
			_clone = Clone();
	}

	/// <summary>
	/// IEditableObject.EndEdit 구현
	/// </summary>
	public void EndEdit()
	{
		_clone = null;
	}

	public abstract void CancelEdit();

	#endregion

	/// <summary>
	/// 객체에 감사정보를 기입한다. 보통 ModifiedAt, ModifiedBy 등의 속성을 기록함.
	/// </summary>
    protected internal virtual partial void WriteAuditInfo();
}

#endregion Entity<T>

#region PropertyChangedEventArgs
/// <summary>
/// 속성 값이 변경된 후 발생하는 이벤트의 매개변수 클래스
/// </summary>
/// <typeparam name="T"></typeparam>
internal class PropertyChangedEventArgs<T> : EventArgs where T : Entity<T>, new()
{
	/// <summary>
	/// 속성 값이 변경된 엔티티
	/// </summary>
	public T Entity { get; set; }

	public PropertyChangedEventArgs(T entity)
	{
		Entity = entity;
	}
}

/// <summary>
/// 속성 값이 변경되기 전 발생하는 이벤트의 매개변수 클래스
/// </summary>
/// <typeparam name="T"></typeparam>
/// <typeparam name="K"></typeparam>
internal class PropertyChangingEventArgs<T, K> : EventArgs where T : Entity<T>, new()
{
	/// <summary>
	/// 속성 값이 변경될 엔티티
	/// </summary>
	public T Entity { get; set; }

	/// <summary>
	/// 새로 변경 될 속성 값
	/// </summary>
	public K Value { get; set; }

	public PropertyChangingEventArgs(T entity, K value)
	{
		Entity = entity;
		Value = value;
	}
}
#endregion

#region EntityDao<T>
public abstract partial class EntityDao<T> where T : Entity<T>, new()
{
	internal EntityDao() { }

	#region Create
	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
	/// </summary>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create()
	{
		return Create(string.Empty, DateTime.Today);
	}

	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultDateTime">기본 DateTime 값</param>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create(DateTime defaultDateTime)
	{
		return Create(string.Empty, defaultDateTime);
	}

	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultString">기본 string 값</param>
	/// <param name="defaultDateTime">기본 DateTime 값</param>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create(string defaultString, DateTime defaultDateTime)
	{
		T entity = new T();
		entity.Clear(defaultString, defaultDateTime);

		return entity;
	}
	#endregion Create

    #region Get
    /// <summary>
    /// 모든 엔터티를 반환한다.
    /// </summary>
    /// <returns>엔터티의 리스트</returns>
    public virtual async Task<List<T>> Get()
        => await Get<T>(null, null, true, 0, int.MaxValue);

    /// <summary>
    /// 조건식에 맞는 엔터티들을 반환한다.
    /// </summary>
    /// <param name="where">조건식</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual async Task<List<T>> Get(Expression<Func<T, bool>> where)
        => await Get<T>(where, null, true, 0, int.MaxValue);

    /// <summary>
    /// 모든 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual async Task<List<T>> Get<O>(Expression<Func<T, O>> orderBy, bool ascending)
        => await Get<O>(null, orderBy, ascending, 0, int.MaxValue);

    /// <summary>
    /// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
    /// <param name="maximumRows">반환할 엔터티의 갯수</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual Task<List<T>> Get<O>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex,
        int maximumRows)
        => Get(null, orderBy, ascending, startRowIndex, maximumRows);

    /// <summary>
    /// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual Task<List<T>> Get<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy,
        bool ascending)
        => Get(where, orderBy, ascending, 0, int.MaxValue);

    /// <summary>
    /// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
    /// <param name="maximumRows">반환할 엔터티의 갯수</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual async Task<List<T>> Get<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        await using var context = DbContextFactory.Create();

        return await GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToListAsync();
    }
    #endregion Get

	#region select
	/// <summary>
	///   모든 선택식의 결과를 반환한다.
	/// </summary>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<S>(Expression<Func<T, S>> select)
        => Select<T, S>(null, null, true, 0, int.MaxValue, select);

	/// <summary>
	///   조건식에 맞는 선택식의 결과를 반환한다.
	/// </summary>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
        => Select<T, S>(where, null, true, 0, int.MaxValue, select);

	/// <summary>
	///   모든 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="O"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<O, S>(Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
        => Select(null, orderBy, ascending, 0, int.MaxValue, select);

	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="O"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
	/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<O, S>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
        => Select(null, orderBy, ascending, startRowIndex, maximumRows, select);
		
	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="O"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
        => Select(where, orderBy, ascending, 0, int.MaxValue, select);

	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징과 프로젝션을을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="O"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
	/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual async Task<List<S>> Select<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        await using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
        return await query.Select(select).ToListAsync();
    }

	private static IQueryable<T> GetListCore<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, DbContext context)
	{
		var query = from x in context.Set<T>()
					select x;

		if (where != null)
			query = query.Where(where);

		IOrderedQueryable<T> orderedQuery = null;

		if (orderBy != null)
			orderedQuery = (ascending) ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

		if (startRowIndex != 0 || maximumRows != int.MaxValue)
		{
			if (orderedQuery != null)
				orderedQuery = (IOrderedQueryable<T>)orderedQuery.Skip(startRowIndex).Take(maximumRows);
			else
				query = query.Skip(startRowIndex).Take(maximumRows);
		}

		return orderedQuery ?? query;
	}
	#endregion select

	#region GetFirst / GetLast
    /// <summary>
    /// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <returns>엔터티</returns>
    public virtual Task<T> GetFirst()
        => GetScalr<T>(null, null, true);

	/// <summary>
	/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <param name="where">조건식</param>
	/// <returns>엔터티</returns>
    public virtual Task<T> GetFirst(Expression<Func<T, bool>> where) 
        => GetScalr<T>(where, null, true);

    /// <summary>
	/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="orderBy">정렬식</param>
	/// <returns>엔터티</returns>
    public virtual Task<T> GetFirst<O>(Expression<Func<T, O>> orderBy)
        => GetScalr<O>(null, orderBy, true);

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <returns>엔터티</returns>
    public virtual Task<T> GetFirst<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy)
        => GetScalr(where, orderBy, true);

	private async Task<T> GetScalr<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending)
	{
        await using var context = DbContextFactory.Create();

	    return await GetScalarCore(where, orderBy, ascending, context).FirstOrDefaultAsync();
	}

    /// <summary>
    /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <returns>엔터티</returns>
    public virtual Task<T> GetLast<O>(Expression<Func<T, O>> orderBy)
        => GetScalr(null, orderBy, false);

	/// <summary>
	/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="orderBy">정렬식</param>
	/// <returns>엔터티</returns>
    public virtual Task<T> GetLast<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy)
        => GetScalr(where, orderBy, false);

    private static IQueryable<T> GetScalarCore<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, DbContext context)
	{
		var query = from x in context.Set<T>()
					select x;

		if (where != null)
			query = query.Where(where);

        // 마지막 행은 orderby가 반드시 지정되어 있어야 함. orderby를 지정하지 않으면 skip 메서드를 사용할 수 없기 때문.
        if (orderBy != null)
			query = @ascending ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

        return query;
	}
	#endregion GetFirst / GetLast

	#region SelectFirst / SelectLast
	/// <summary>
	/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual Task<S> SelectFirst<S>(Expression<Func<T, S>> select)
        => SelectScalar<T, S>(null, null, select, false);

	/// <summary>
	/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="S">선택 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual Task<S> SelectFirst<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
        => SelectScalar<T, S>(where, null, select, false);

	/// <summary>
	/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
	/// <typeparam name="S">선택 형식</typeparam>
	/// <param name="orderBy">정렬식</param>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual Task<S> SelectFirst<O, S>(Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(null, orderBy, select, true);

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="S">선택 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <returns>엔터티</returns>
    public virtual Task<S> SelectFirst<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(where, orderBy, select, true);

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="S">선택 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <returns>엔터티</returns>
    private async Task<S> SelectScalar<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select, bool ascending)
	{
        await using var context = DbContextFactory.Create();

		var query = GetScalarCore(where, orderBy, ascending, context);
		return await query.Select(select).FirstOrDefaultAsync();
	}

    /// <summary>
    /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="S">선택 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <returns>엔터티</returns>
    public virtual Task<S> SelectLast<O, S>(Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(null, orderBy, select, false);

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="S">선택 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <returns>엔터티</returns>
    public virtual Task<S> SelectLast<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(where, orderBy, select, false);
    #endregion SelectFirst / SelectLast

	#region GetCount
	/// <summary>
	/// 모든 엔터티의 갯수를 구한다.
	/// </summary>
	/// <returns>엔터티의 갯수</returns>
    public virtual Task<int> GetCount()
        => GetCount(null);

    /// <summary>
    /// 조건식에 맞는 엔터티의 갯수를 구한다.
    /// </summary>
    /// <param name="where">조건식</param>
    /// <returns>엔터티의 갯수</returns>
    public virtual async Task<int> GetCount(Expression<Func<T, bool>> where)
    {
        await using var context = DbContextFactory.Create();

        var query = MakeCountQuery(where, context);
        return await query.CountAsync();
    }

    private IQueryable<T> MakeCountQuery(Expression<Func<T, bool>> where, DbContext context)
    {
        var query = from item in context.Set<T>()
            select item;

        if (where != null)
            query = query.Where(where);

        return query;
    }
	#endregion GetCount

	#region Exist
	/// <summary>
	/// 조건식에 맞는 엔터티가 존재하는지 검사한다.
	/// </summary>
	/// <param name="where">조건식</param>
	/// <returns>존재 여부</returns>
    public virtual async Task<bool> Exists(Expression<Func<T, bool>> where)
    {
        await using var context = DbContextFactory.Create();

        var query = MakeCountQuery(where, context);
        return await query.AnyAsync();
    }
	#endregion Exist

	#region Write log partial methods
	protected virtual partial void OnSaving(T entity, LogType logType);

	/// <summary>
	/// 엔티티의 로그를 기록한다.
	/// </summary>
	/// <param name="entity">엔티티</param>
	/// <param name="logType">로그 타입</param>
	protected virtual partial void OnSaved(T entity, LogType logType);
	#endregion Write log partial methods

	#region Insert / Update / Delete
    internal virtual void MarkToSave(DbContext context, LogType logType, T entity)
    {
        OnSaving(entity, logType);

        context.Entry(entity).State = logType switch
        {
            LogType.Insert => EntityState.Added,
            LogType.Update => EntityState.Modified,
            LogType.Delete => EntityState.Deleted,
			_ => throw new ArgumentOutOfRangeException(nameof(logType), logType, null)
        };
    }
    
    internal async Task<(int Count, T Entity)> SaveChanges(LogType logType, params IEnumerable<T> entities)
	{
        await using var context = DbContextFactory.Create();

        foreach (var entity in entities)
    		MarkToSave(context, logType, entity);
			
		int count = await context.SaveChangesAsync();
		if (count > 0)
            foreach (var entity in entities)
    			OnSaved(entity, logType);

        return (count, count > 0 ? entities.First() : null);
	}

	public virtual async Task<T> Insert(T entity)
        => (await SaveChanges(LogType.Insert, entity)).Entity;

	public virtual async Task<int> InsertMany(IEnumerable<T> entities)
        => (await SaveChanges(LogType.Insert, entities)).Count;

	public virtual async Task<int> Update(T entity) 
        => (await SaveChanges(LogType.Update, entity)).Count;

	public virtual async Task<int> UpdateMany(IEnumerable<T> entities) 
        => (await SaveChanges(LogType.Update, entities)).Count;

	public virtual async Task<int> Delete(T entity) 
        => (await SaveChanges(LogType.Delete, entity)).Count;

	public virtual async Task<int> DeleteMany(IEnumerable<T> entities) 
        => (await SaveChanges(LogType.Delete, entities)).Count;

	public virtual async Task<int> DeleteAll(Expression<Func<T, bool>> where)
	{
        await using var context = DbContextFactory.Create();

		var entities = await Get(where);

        return await DeleteMany(entities);
	}

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
    /// <returns>삽입된 엔터티</returns>
    public virtual async Task<T> InsertIfNotExist(T entity)
    {
        await using var context = DbContextFactory.Create();

        int count = await context.Set<T>().CountAsync(HasSameKey(entity));
        if (count > 0)
            return null;

        return await Insert(entity);
    }

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
    /// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
    /// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual async Task<bool> InsertOrUpdate(T entity, bool withAudit = false)
    {
        await using var context = DbContextFactory.Create();

        int count = await context.Set<T>().CountAsync(HasSameKey(entity));
        if (count > 0)
        {
            await Update(entity);
            return false;
        }
        else
        {
            await Insert(entity);
            return true;
        }
    }	
	#endregion Insert / Update / Delete

    #region ExecuteUpdate / ExecuteDelete
    /// <summary>
    /// 조건식을 만족하는 엔티티를 일괄 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="predicate">조건식</param>
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. 예)p => p.TypeCode, p => p.TypeCode + 1</param>
    /// <returns></returns>
    public async Task<int> ExecuteUpdate(Expression<Func<T, bool>> predicate, Expression<Func<SetPropertyCalls<T>, SetPropertyCalls<T>>> setPropertyCalls)
    {
        await using var context = DbContextFactory.Create();

        return await context.Set<T>().Where(predicate).ExecuteUpdateAsync(setPropertyCalls);
    }

    /// <summary>
    /// 조건식을 만족하는 엔티티를 일괄 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="predicate">조건식</param>
    /// <returns></returns>
    public async Task<int> ExecuteDelete(Expression<Func<T, bool>> predicate)
    {
        await using var context = DbContextFactory.Create();

        return await context.Set<T>().Where(predicate).ExecuteDeleteAsync();
    }
    #endregion ExecuteUpdate / ExecuteDelete

    protected abstract Expression<Func<T, bool>> HasSameKey(T other);
}
#endregion EntityDao

#region Types
/// <summary>
/// 엔티티를 추가/수정/삭제 할 때 기록하는 로그의 종류
/// </summary>
public enum LogType
{
	/// <summary>
	/// 엔티티 삽입
	/// </summary>
	Insert,
	/// <summary>
	/// 엔티티 갱신
	/// </summary>
	Update,
	/// <summary>
	/// 엔티티 삭제
	/// </summary>
	Delete
}
#endregion

#region DaoBase
/// <summary>
/// Dao의 부모. Dao를 확장하는 용도로 사용한다.
/// </summary>
public partial class DaoBase
{
}
#endregion

#region `DbContextName`LoggerFactory
/// <summary>
/// 간단하게 사용할 수 있는 엔터티 프레임워크 코어용 로거 팩토리. Console과 Debug의 출력창 혹은 파일에 저장 할 수 있음
/// </summary>
internal class `DbContextName`LoggerFactory : LoggerFactory
{
    #region singleton
    private static `DbContextName`LoggerFactory _instance;

    public static `DbContextName`LoggerFactory GetInstance(params LogPath[] loggerTypes) => GetInstance(loggerTypes.Select(x => x.ToString()).ToArray());

    public static `DbContextName`LoggerFactory GetInstance(params string[] logPathes)
    {
        if (_instance == null)
        {
            List<ILoggerProvider> logProviders = new List<ILoggerProvider>(logPathes.Select(x => new LogProvider(x)));
            _instance = new `DbContextName`LoggerFactory(logProviders);
        }

        return _instance;
    }

    private `DbContextName`LoggerFactory(List<ILoggerProvider> providers) : base(providers)
    {
    }

    #endregion singleton

    internal class LogProvider : ILoggerProvider
    {
        public LogProvider(string logPath) => _logPath = logPath;

        private string _logPath;

        public void Dispose()
        {
        }

        public ILogger CreateLogger(string categoryName)
        {
            return new Logger(categoryName, _logPath);
        }
    }

    internal class Logger : ILogger
    {
        private readonly IWriter _writer;

        private readonly string _categoryName;

        public Logger(string categoryName, string logPath)
        {
            _categoryName = categoryName;

            _writer = logPath switch
            {
                nameof(LogPath.Console) => new ConsoleWriter(),
                nameof(LogPath.Debug) => new DebugWriter(),
                _ => new FileWriter(logPath),
            };

            if (_counters.ContainsKey(_writer.UniqueName) is false)
                _counters.TryAdd(_writer.UniqueName, 0);
        }

        private static System.Collections.Concurrent.ConcurrentDictionary<string, int> _counters = new();

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
        {
            _writer.Open();
            _writer.WriteLine($"[{_counters[_writer.UniqueName]++:N0}] {DateTime.Now:s}");
            _writer.WriteLine(formatter(state, exception));
            _writer.WriteLine("--------------------------------------------------");
            _writer.WriteLine(Environment.NewLine);
            _writer.Save();
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return logLevel == LogLevel.Information &&
                    _categoryName == DbLoggerCategory.Database.Command.Name;
        }

        public IDisposable BeginScope<TState>(TState state)
        {
            return null;
        }
    }

    public interface IWriter
    {
        string UniqueName { get; }

        void WriteLine(string format, params object[] args);

        void Open()
        {
        }

        void Save()
        {
        }
    }

    internal class ConsoleWriter : IWriter
    {
        public string UniqueName => nameof(ConsoleWriter);

        public void WriteLine(string format, params object[] args) => Console.WriteLine(format, args);
    }

    internal class DebugWriter : IWriter
    {
        public string UniqueName => nameof(DebugWriter);

        public void WriteLine(string format, params object[] args) => Debug.WriteLine(format, args);
    }

    internal class FileWriter : IWriter
    {
        private readonly string _logFilePath;

        public string UniqueName => _logFilePath;

        public FileWriter(string logFilePath)
        {
            _logFilePath = logFilePath;
        }

        private readonly StringBuilder _builder = new StringBuilder();

        public void WriteLine(string format, params object[] args)
        {
            _builder.AppendFormat(format, args);
            _builder.AppendLine();
        }

        public void Open()
        {
            _builder.Clear();
        }

        public void Save()
        {
            File.AppendAllText(_logFilePath, _builder.ToString());
        }
    }
}

internal enum LogPath
{
    /// <summary>
    /// 콘솔에 출력
    /// </summary>
    Console,
    /// <summary>
    /// 디버거 창에 출력
    /// </summary>
    Debug,
}
#endregion `DbContextName`LoggerFactory

#region Entities
`T #region `Name`
/// <summary>
/// `Name` 엔터티
/// </summary>
public partial class `Name` : Entity<`Name`>, IEntity
{
	public const string EntityTypeName = "`Name`";

	public static void Copy(`Name` source, `Name` target)
	{
		`A:[T][T][N]:target.`Name` = source.`Name`; ``
	}

	/// <summary>
	/// `Name` 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override `Name` Clone()
	{
		var clone = new `Name`();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// `Name` 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return `A: + ", " + :"[`Name`]" + `Name` ``;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", `P:, :`Name` ``); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		`P:[N]:`Name` = default;``
	}
}

/// <summary>
/// `Name` 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum `Name`Column
{
	`A:,[N]:`Name` ``
}

/// <summary>
/// `Name` 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;`Name`&gt; 구현)
/// </summary>
public class `Name`EqualityComparer : IEqualityComparer<`Name`>
{
    #region singleton
    private static readonly Lazy<`Name`EqualityComparer> _instance = new(() => new `Name`EqualityComparer());

    public static `Name`EqualityComparer Instance => _instance.Value;

    private `Name`EqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(`Name` x, `Name` y)
	{
		return `P: && :x.`Name` == y.`Name` ``;
	}

	public int GetHashCode(`Name` obj)
	{
		return `P: ^ :obj.`Name`.GetHashCode() ``;
	}
}
#endregion `Name`
T`
#endregion Entities

#region EntityDao
`T #region `Name`Dao
/// <summary>
/// `Name` 데이터 클래스
/// </summary>
public partial class `Name`Dao : EntityDao<`Name`>
{
	internal `Name`Dao() {}

	protected override Expression<Func<`Name`, bool>> HasSameKey(`Name` other)
	{
        return x => `P: &&:x.`Name` == other.`Name` ``;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	`P:[N]:/// <param name="`name`">기본키</param>``
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<`Name`> GetByKey(`P:, :`Type` `name` ``)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<`Name`>().FirstOrDefaultAsync(x => `P: && : x.`Name` == `name` ``);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	`P:[N]:/// <param name="`name`">기본키</param>``
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(`P:, :`Type` `name` ``)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<`Name`>().CountAsync(x => `P: && : x.`Name` == `name` ``) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	`P::/// <param name="`name`">기본키</param> ``
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(`P:, :`Type` `name` ``)
	{
        var entity = await GetByKey(`P:, :`name` ``);

        if (entity == null)
            return 0;

        return await Delete(entity);
	}
	
	`F::
	#region GetBy`Name`
    private IQueryable<`Table`> GetBy`Name`Core(DbContext context, `Type` `name`)
    {
        return context.Set<`Table`>().Where(x => x.`Name` == `name`);
    }

    public async Task<List<`Table`>> GetBy`Name`(`Type` `name`, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBy`Name`Core(context, `name`).ToListAsync(ctk);
    }
    
    public async Task<`Table`[]> GetBy`Name`AsArray(`Type` `name`, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBy`Name`Core(context, `name`).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<`Table`>> GetBy`Name`AsHastSet(`Type` `name`, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBy`Name`Core(context, `name`).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, `Table`>> GetBy`Name`AsDictionary<K>(`Type` `name`, Func<`Table`, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBy`Name`Core(context, `name`).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetBy`Name`AsDictionary<K, E>(`Type` `name`, Func<`Table`, K> keySelector,Func<`Table`, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBy`Name`Core(context, `name`).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    ``

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    `P::/// <param name="`name`">기본키</param> ``
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(`P:, :`Type` `name` ``)
        => ExecuteDelete(x => `P:&& :x.`Name` == `name` ``);

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    `P::/// <param name="`name`">기본키</param> ``
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(`P:, :`Type` `name` ``, Expression<Func<SetPropertyCalls<`Name`>, SetPropertyCalls<`Name`>>> setPropertyCalls)
        => ExecuteUpdate(x => `P:&& :x.`Name` == `name` ``, setPropertyCalls);
}
#endregion `Name`Dao
T`
#endregion EntityDao

#region Dao
/// <summary>
/// 각 엔터티 데이터 객체의 모음
/// </summary>
public partial class Dao : DaoBase
{
	static Dao()
	{
		`T `Name` = new `Name`Dao(); T`
	}

	#region Data objects
	`T public static `Name`Dao `Name` { get; } T`
	#endregion

	public static EntityDao<T> Get<T>() where T : Entity<T>, new()
    {
        object result = typeof(T).Name switch
        {
            `T "`Name`" => `Name`, T`
			_ => throw new NotImplementedException("Dao.Get")
        };

        return result as EntityDao<T>;
    }
}
#endregion