// <auto-generated> This file has been generated by Gccg</auto-generated>

#region usings
using System.ComponentModel;
using System.ComponentModel.DataAnnotations.Schema;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.Json.Serialization;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using Microsoft.Extensions.Logging;
using Chinook.Data;
#endregion

namespace Chinook.Data;

#region EntityDao<T>
public abstract partial class EntityDao<T> where T : Entity<T>, new()
{
    #region Get
    public virtual List<T> Get()
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToList();
    }

    public virtual T[] GetAsArray()
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToArray();
    }

    public virtual HashSet<T> GetAsHashSet()
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToHashSet();
    }

    public virtual Dictionary<K, T> GetAsDictionary<K>(Func<T, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToDictionary(keySelector);
    }

    public virtual Dictionary<K, E> GetAsDictionary<K, E>(Func<T, K> keySelector, Func<T, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(null, null, true, 0, int.MaxValue, context).ToDictionary(keySelector, elementSelector);
    }

    public virtual List<T> Get(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToList();
    }

    public virtual T[] GetAsArray(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToArray();
    }

    public virtual HashSet<T> GetAsHashSet(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToHashSet();
    }

    public virtual Dictionary<K, T> GetAsDictionary<K>(
        Expression<Func<T, bool>> where, Func<T, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToDictionary(keySelector);
    }

    public virtual Dictionary<K, E> GetAsDictionary<K, E>(
        Expression<Func<T, bool>> where, Func<T, K> keySelector, Func<T, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetListCore<T>(where, null, true, 0, int.MaxValue, context).ToDictionary(keySelector, elementSelector);
    }

    public virtual List<T> Get<O>(Expression<Func<T, O>> orderBy, bool ascending)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(null, orderBy, ascending, 0, int.MaxValue, context).ToList();
    }

    public virtual T[] GetAsArray<O>(Expression<Func<T, O>> orderBy, bool ascending)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(null, orderBy, ascending, 0, int.MaxValue, context).ToArray();
    }

    public virtual List<T> Get<O>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(null, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
    }
    
    public virtual T[] GetAsArray<O>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(null, orderBy, ascending, startRowIndex, maximumRows, context).ToArray();
    }

    public virtual List<T> Get<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(where, orderBy, ascending, 0, int.MaxValue, context).ToList();
    }

    public virtual T[] GetAsArray<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(where, orderBy, ascending, 0, int.MaxValue, context).ToArray();
    }

    public virtual List<T> Get<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
    }
    
    public virtual T[] GetAsArray<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        using var context = DbContextFactory.Create();

        return GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToArray();
    }
    #endregion Get

	#region Select
    public virtual List<S> Select<S>(Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(null, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<S>(Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(null, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToArray();
    }

    public virtual HashSet<S> SelectAsHashSet<S>(Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(null, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToHashSet();
    }

    public virtual List<S> Select<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(where, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(where, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToArray();
    }

    public virtual HashSet<S> SelectAsHashSet<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore<T>(where, null, true, 0, int.MaxValue, context);
        return query.Select(select).ToHashSet();
    }

    public virtual List<S> Select<O, S>(Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(null, orderBy, ascending, 0, int.MaxValue, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<O, S>(Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(null, orderBy, ascending, 0, int.MaxValue, context);
        return query.Select(select).ToArray();
    }

    public virtual List<S> Select<O, S>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(null, orderBy, ascending, startRowIndex, maximumRows, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<O, S>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(null, orderBy, ascending, startRowIndex, maximumRows, context);
        return query.Select(select).ToArray();
    }

    public virtual List<S> Select<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, 0, int.MaxValue, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, 0, int.MaxValue, context);
        return query.Select(select).ToArray();
    }

    public virtual List<S> Select<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
        return query.Select(select).ToList();
    }

    public virtual S[] SelectAsArray<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
        return query.Select(select).ToArray();
    }
	#endregion Select

	#region GetFirst / GetLast
    public virtual T GetFirst()
        => GetScalar<T>(null, null, true);

    public virtual T GetFirst(Expression<Func<T, bool>> where) 
        => GetScalar<T>(where, null, true);

    public virtual T GetFirst<O>(Expression<Func<T, O>> orderBy)
        => GetScalar<O>(null, orderBy, true);

    public virtual T GetFirst<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy)
        => GetScalar(where, orderBy, true);

	private T GetScalar<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending)
	{
        using var context = DbContextFactory.Create();

	    return GetScalarCore(where, orderBy, ascending, context).FirstOrDefault();
	}

    public virtual T GetLast<O>(Expression<Func<T, O>> orderBy)
        => GetScalar(null, orderBy, false);

    public virtual T GetLast<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy)
        => GetScalar(where, orderBy, false);
	#endregion GetFirst / GetLast

	#region SelectFirst / SelectLast
    public virtual S SelectFirst<S>(Expression<Func<T, S>> select)
        => SelectScalar<T, S>(null, null, select, false);

    public virtual S SelectFirst<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
        => SelectScalar<T, S>(where, null, select, false);

    public virtual S SelectFirst<O, S>(Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(null, orderBy, select, true);

    public virtual S SelectFirst<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(where, orderBy, select, true);

    private S SelectScalar<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select, bool ascending)
	{
        using var context = DbContextFactory.Create();

		var query = GetScalarCore(where, orderBy, ascending, context);
		return query.Select(select).FirstOrDefault();
	}

    public virtual S SelectLast<O, S>(Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(null, orderBy, select, false);

    public virtual S SelectLast<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select)
        => SelectScalar(where, orderBy, select, false);
    #endregion SelectFirst / SelectLast

	#region GetCount
    public virtual int GetCount()
        => GetCount(null);

    public virtual int GetCount(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        var query = MakeCountQuery(where, context);
        return query.Count();
    }
	#endregion GetCount

	#region Exist
    public virtual bool Exists(Expression<Func<T, bool>> where)
    {
        using var context = DbContextFactory.Create();

        var query = MakeCountQuery(where, context);
        return query.Any();
    }
	#endregion Exist

	#region Insert / Update / Delete
    
    internal (int Count, T Entity) SaveChanges(LogType logType, params IEnumerable<T> entities)
	{
        using var context = DbContextFactory.Create();

        foreach (var entity in entities)
    		MarkToSave(context, logType, entity);
			
		int count = context.SaveChanges();
		if (count > 0)
            foreach (var entity in entities)
    			OnSaved(entity, logType);

        return (count, count > 0 ? entities.First() : null);
	}

	public virtual T Insert(T entity)
        => (SaveChanges(LogType.Insert, entity)).Entity;

	public virtual int InsertMany(IEnumerable<T> entities)
        => (SaveChanges(LogType.Insert, entities)).Count;

	public virtual int Update(T entity) 
        => (SaveChanges(LogType.Update, entity)).Count;

	public virtual int UpdateMany(IEnumerable<T> entities) 
        => (SaveChanges(LogType.Update, entities)).Count;

	public virtual int Delete(T entity) 
        => (SaveChanges(LogType.Delete, entity)).Count;

	public virtual int DeleteMany(IEnumerable<T> entities) 
        => (SaveChanges(LogType.Delete, entities)).Count;

	public virtual int DeleteAll(Expression<Func<T, bool>> where)
	{
        using var context = DbContextFactory.Create();

		var entities = Get(where);

        return DeleteMany(entities);
	}

    public virtual T InsertIfNotExist(T entity)
    {
        using var context = DbContextFactory.Create();

        int count = context.Set<T>().Count(HasSameKey(entity));
        if (count > 0)
            return null;

        return Insert(entity);
    }

    public virtual bool InsertOrUpdate(T entity, bool withAudit = false)
    {
        using var context = DbContextFactory.Create();

        int count = context.Set<T>().Count(HasSameKey(entity));
        if (count > 0)
        {
            Update(entity);
            return false;
        }
        else
        {
            Insert(entity);
            return true;
        }
    }	
	#endregion Insert / Update / Delete

    #region ExecuteUpdate / ExecuteDelete
    public int ExecuteUpdate(Expression<Func<T, bool>> predicate, Expression<Func<SetPropertyCalls<T>, SetPropertyCalls<T>>> setPropertyCalls)
    {
        using var context = DbContextFactory.Create();

        return context.Set<T>().Where(predicate).ExecuteUpdate(setPropertyCalls);
    }

    public int ExecuteDelete(Expression<Func<T, bool>> predicate)
    {
        using var context = DbContextFactory.Create();

        return context.Set<T>().Where(predicate).ExecuteDelete();
    }
    #endregion ExecuteUpdate / ExecuteDelete
}
#endregion EntityDao<T>

 #region AlbumDao
/// <summary>
/// Album 데이터 클래스
/// </summary>
public partial class AlbumDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="albumId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Album GetByKey(int albumId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Album>().FirstOrDefault(x =>  x.AlbumId == albumId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="albumId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int albumId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Album>().Count(x =>  x.AlbumId == albumId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="albumId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int albumId )
	{
        var entity = GetByKey(albumId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetByArtistId
    public List<Album> GetByArtistId(int artistId)
    {
        using var context = DbContextFactory.Create();

        return GetByArtistIdCore(context, artistId).ToList();
    }
    
    public Album[] GetByArtistIdAsArray(int artistId)
    {
        using var context = DbContextFactory.Create();

        return GetByArtistIdCore(context, artistId).ToArray();
    }
    
    public HashSet<Album> GetByArtistIdAsHastSet(int artistId)
    {
        using var context = DbContextFactory.Create();

        return GetByArtistIdCore(context, artistId).ToHashSet();
    }
    
    public Dictionary<K, Album> GetByArtistIdAsDictionary<K>(int artistId, Func<Album, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByArtistIdCore(context, artistId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByArtistIdAsDictionary<K, E>(int artistId, Func<Album, K> keySelector,Func<Album, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByArtistIdCore(context, artistId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="albumId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int albumId )
        => ExecuteDelete(x => x.AlbumId == albumId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="albumId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int albumId , Expression<Func<SetPropertyCalls<Album>, SetPropertyCalls<Album>>> setPropertyCalls)
        => ExecuteUpdate(x => x.AlbumId == albumId , setPropertyCalls);
}
#endregion AlbumDao

 #region ArtistDao
/// <summary>
/// Artist 데이터 클래스
/// </summary>
public partial class ArtistDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="artistId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Artist GetByKey(int artistId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Artist>().FirstOrDefault(x =>  x.ArtistId == artistId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="artistId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int artistId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Artist>().Count(x =>  x.ArtistId == artistId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="artistId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int artistId )
	{
        var entity = GetByKey(artistId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="artistId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int artistId )
        => ExecuteDelete(x => x.ArtistId == artistId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="artistId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int artistId , Expression<Func<SetPropertyCalls<Artist>, SetPropertyCalls<Artist>>> setPropertyCalls)
        => ExecuteUpdate(x => x.ArtistId == artistId , setPropertyCalls);
}
#endregion ArtistDao

 #region CodeDao
/// <summary>
/// Code 데이터 클래스
/// </summary>
public partial class CodeDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="codeId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Code GetByKey(int codeId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Code>().FirstOrDefault(x =>  x.CodeId == codeId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="codeId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int codeId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Code>().Count(x =>  x.CodeId == codeId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="codeId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int codeId )
	{
        var entity = GetByKey(codeId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetByCodeCategoryId
    public List<Code> GetByCodeCategoryId(int codeCategoryId)
    {
        using var context = DbContextFactory.Create();

        return GetByCodeCategoryIdCore(context, codeCategoryId).ToList();
    }
    
    public Code[] GetByCodeCategoryIdAsArray(int codeCategoryId)
    {
        using var context = DbContextFactory.Create();

        return GetByCodeCategoryIdCore(context, codeCategoryId).ToArray();
    }
    
    public HashSet<Code> GetByCodeCategoryIdAsHastSet(int codeCategoryId)
    {
        using var context = DbContextFactory.Create();

        return GetByCodeCategoryIdCore(context, codeCategoryId).ToHashSet();
    }
    
    public Dictionary<K, Code> GetByCodeCategoryIdAsDictionary<K>(int codeCategoryId, Func<Code, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByCodeCategoryIdCore(context, codeCategoryId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByCodeCategoryIdAsDictionary<K, E>(int codeCategoryId, Func<Code, K> keySelector,Func<Code, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByCodeCategoryIdCore(context, codeCategoryId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="codeId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int codeId )
        => ExecuteDelete(x => x.CodeId == codeId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="codeId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int codeId , Expression<Func<SetPropertyCalls<Code>, SetPropertyCalls<Code>>> setPropertyCalls)
        => ExecuteUpdate(x => x.CodeId == codeId , setPropertyCalls);
}
#endregion CodeDao

 #region CodeCategoryDao
/// <summary>
/// CodeCategory 데이터 클래스
/// </summary>
public partial class CodeCategoryDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="codeCategoryId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public CodeCategory GetByKey(int codeCategoryId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<CodeCategory>().FirstOrDefault(x =>  x.CodeCategoryId == codeCategoryId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="codeCategoryId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int codeCategoryId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<CodeCategory>().Count(x =>  x.CodeCategoryId == codeCategoryId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="codeCategoryId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int codeCategoryId )
	{
        var entity = GetByKey(codeCategoryId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="codeCategoryId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int codeCategoryId )
        => ExecuteDelete(x => x.CodeCategoryId == codeCategoryId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="codeCategoryId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int codeCategoryId , Expression<Func<SetPropertyCalls<CodeCategory>, SetPropertyCalls<CodeCategory>>> setPropertyCalls)
        => ExecuteUpdate(x => x.CodeCategoryId == codeCategoryId , setPropertyCalls);
}
#endregion CodeCategoryDao

 #region CustomerDao
/// <summary>
/// Customer 데이터 클래스
/// </summary>
public partial class CustomerDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="customerId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Customer GetByKey(int customerId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Customer>().FirstOrDefault(x =>  x.CustomerId == customerId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="customerId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int customerId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Customer>().Count(x =>  x.CustomerId == customerId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="customerId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int customerId )
	{
        var entity = GetByKey(customerId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetBySupportRepId
    public List<Customer> GetBySupportRepId(int? supportRepId)
    {
        using var context = DbContextFactory.Create();

        return GetBySupportRepIdCore(context, supportRepId).ToList();
    }
    
    public Customer[] GetBySupportRepIdAsArray(int? supportRepId)
    {
        using var context = DbContextFactory.Create();

        return GetBySupportRepIdCore(context, supportRepId).ToArray();
    }
    
    public HashSet<Customer> GetBySupportRepIdAsHastSet(int? supportRepId)
    {
        using var context = DbContextFactory.Create();

        return GetBySupportRepIdCore(context, supportRepId).ToHashSet();
    }
    
    public Dictionary<K, Customer> GetBySupportRepIdAsDictionary<K>(int? supportRepId, Func<Customer, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetBySupportRepIdCore(context, supportRepId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetBySupportRepIdAsDictionary<K, E>(int? supportRepId, Func<Customer, K> keySelector,Func<Customer, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetBySupportRepIdCore(context, supportRepId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="customerId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int customerId )
        => ExecuteDelete(x => x.CustomerId == customerId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="customerId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int customerId , Expression<Func<SetPropertyCalls<Customer>, SetPropertyCalls<Customer>>> setPropertyCalls)
        => ExecuteUpdate(x => x.CustomerId == customerId , setPropertyCalls);
}
#endregion CustomerDao

 #region DateTableDao
/// <summary>
/// DateTable 데이터 클래스
/// </summary>
public partial class DateTableDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="date">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public DateTable GetByKey(DateOnly date )
	{
        using var context = DbContextFactory.Create();

        return context.Set<DateTable>().FirstOrDefault(x =>  x.Date == date );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="date">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(DateOnly date )
	{
        using var context = DbContextFactory.Create();

		return context.Set<DateTable>().Count(x =>  x.Date == date ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="date">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(DateOnly date )
	{
        var entity = GetByKey(date );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="date">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(DateOnly date )
        => ExecuteDelete(x => x.Date == date );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="date">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(DateOnly date , Expression<Func<SetPropertyCalls<DateTable>, SetPropertyCalls<DateTable>>> setPropertyCalls)
        => ExecuteUpdate(x => x.Date == date , setPropertyCalls);
}
#endregion DateTableDao

 #region EmployeeDao
/// <summary>
/// Employee 데이터 클래스
/// </summary>
public partial class EmployeeDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="employeeId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Employee GetByKey(int employeeId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Employee>().FirstOrDefault(x =>  x.EmployeeId == employeeId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="employeeId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int employeeId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Employee>().Count(x =>  x.EmployeeId == employeeId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="employeeId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int employeeId )
	{
        var entity = GetByKey(employeeId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetByReportsTo
    public List<Employee> GetByReportsTo(int? reportsTo)
    {
        using var context = DbContextFactory.Create();

        return GetByReportsToCore(context, reportsTo).ToList();
    }
    
    public Employee[] GetByReportsToAsArray(int? reportsTo)
    {
        using var context = DbContextFactory.Create();

        return GetByReportsToCore(context, reportsTo).ToArray();
    }
    
    public HashSet<Employee> GetByReportsToAsHastSet(int? reportsTo)
    {
        using var context = DbContextFactory.Create();

        return GetByReportsToCore(context, reportsTo).ToHashSet();
    }
    
    public Dictionary<K, Employee> GetByReportsToAsDictionary<K>(int? reportsTo, Func<Employee, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByReportsToCore(context, reportsTo).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByReportsToAsDictionary<K, E>(int? reportsTo, Func<Employee, K> keySelector,Func<Employee, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByReportsToCore(context, reportsTo).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="employeeId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int employeeId )
        => ExecuteDelete(x => x.EmployeeId == employeeId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="employeeId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int employeeId , Expression<Func<SetPropertyCalls<Employee>, SetPropertyCalls<Employee>>> setPropertyCalls)
        => ExecuteUpdate(x => x.EmployeeId == employeeId , setPropertyCalls);
}
#endregion EmployeeDao

 #region GenreDao
/// <summary>
/// Genre 데이터 클래스
/// </summary>
public partial class GenreDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="genreId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Genre GetByKey(int genreId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Genre>().FirstOrDefault(x =>  x.GenreId == genreId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="genreId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int genreId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Genre>().Count(x =>  x.GenreId == genreId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="genreId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int genreId )
	{
        var entity = GetByKey(genreId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="genreId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int genreId )
        => ExecuteDelete(x => x.GenreId == genreId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="genreId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int genreId , Expression<Func<SetPropertyCalls<Genre>, SetPropertyCalls<Genre>>> setPropertyCalls)
        => ExecuteUpdate(x => x.GenreId == genreId , setPropertyCalls);
}
#endregion GenreDao

 #region InvoiceDao
/// <summary>
/// Invoice 데이터 클래스
/// </summary>
public partial class InvoiceDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="invoiceId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Invoice GetByKey(int invoiceId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Invoice>().FirstOrDefault(x =>  x.InvoiceId == invoiceId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="invoiceId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int invoiceId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Invoice>().Count(x =>  x.InvoiceId == invoiceId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="invoiceId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int invoiceId )
	{
        var entity = GetByKey(invoiceId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetByCustomerId
    public List<Invoice> GetByCustomerId(int customerId)
    {
        using var context = DbContextFactory.Create();

        return GetByCustomerIdCore(context, customerId).ToList();
    }
    
    public Invoice[] GetByCustomerIdAsArray(int customerId)
    {
        using var context = DbContextFactory.Create();

        return GetByCustomerIdCore(context, customerId).ToArray();
    }
    
    public HashSet<Invoice> GetByCustomerIdAsHastSet(int customerId)
    {
        using var context = DbContextFactory.Create();

        return GetByCustomerIdCore(context, customerId).ToHashSet();
    }
    
    public Dictionary<K, Invoice> GetByCustomerIdAsDictionary<K>(int customerId, Func<Invoice, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByCustomerIdCore(context, customerId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByCustomerIdAsDictionary<K, E>(int customerId, Func<Invoice, K> keySelector,Func<Invoice, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByCustomerIdCore(context, customerId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="invoiceId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int invoiceId )
        => ExecuteDelete(x => x.InvoiceId == invoiceId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="invoiceId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int invoiceId , Expression<Func<SetPropertyCalls<Invoice>, SetPropertyCalls<Invoice>>> setPropertyCalls)
        => ExecuteUpdate(x => x.InvoiceId == invoiceId , setPropertyCalls);
}
#endregion InvoiceDao

 #region InvoiceLineDao
/// <summary>
/// InvoiceLine 데이터 클래스
/// </summary>
public partial class InvoiceLineDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="invoiceLineId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public InvoiceLine GetByKey(int invoiceLineId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<InvoiceLine>().FirstOrDefault(x =>  x.InvoiceLineId == invoiceLineId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="invoiceLineId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int invoiceLineId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<InvoiceLine>().Count(x =>  x.InvoiceLineId == invoiceLineId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="invoiceLineId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int invoiceLineId )
	{
        var entity = GetByKey(invoiceLineId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetByInvoiceId
    public List<InvoiceLine> GetByInvoiceId(int invoiceId)
    {
        using var context = DbContextFactory.Create();

        return GetByInvoiceIdCore(context, invoiceId).ToList();
    }
    
    public InvoiceLine[] GetByInvoiceIdAsArray(int invoiceId)
    {
        using var context = DbContextFactory.Create();

        return GetByInvoiceIdCore(context, invoiceId).ToArray();
    }
    
    public HashSet<InvoiceLine> GetByInvoiceIdAsHastSet(int invoiceId)
    {
        using var context = DbContextFactory.Create();

        return GetByInvoiceIdCore(context, invoiceId).ToHashSet();
    }
    
    public Dictionary<K, InvoiceLine> GetByInvoiceIdAsDictionary<K>(int invoiceId, Func<InvoiceLine, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByInvoiceIdCore(context, invoiceId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByInvoiceIdAsDictionary<K, E>(int invoiceId, Func<InvoiceLine, K> keySelector,Func<InvoiceLine, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByInvoiceIdCore(context, invoiceId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="invoiceLineId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int invoiceLineId )
        => ExecuteDelete(x => x.InvoiceLineId == invoiceLineId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="invoiceLineId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int invoiceLineId , Expression<Func<SetPropertyCalls<InvoiceLine>, SetPropertyCalls<InvoiceLine>>> setPropertyCalls)
        => ExecuteUpdate(x => x.InvoiceLineId == invoiceLineId , setPropertyCalls);
}
#endregion InvoiceLineDao

 #region MediaTypeDao
/// <summary>
/// MediaType 데이터 클래스
/// </summary>
public partial class MediaTypeDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="mediaTypeId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public MediaType GetByKey(int mediaTypeId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<MediaType>().FirstOrDefault(x =>  x.MediaTypeId == mediaTypeId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="mediaTypeId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int mediaTypeId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<MediaType>().Count(x =>  x.MediaTypeId == mediaTypeId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="mediaTypeId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int mediaTypeId )
	{
        var entity = GetByKey(mediaTypeId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="mediaTypeId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int mediaTypeId )
        => ExecuteDelete(x => x.MediaTypeId == mediaTypeId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="mediaTypeId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int mediaTypeId , Expression<Func<SetPropertyCalls<MediaType>, SetPropertyCalls<MediaType>>> setPropertyCalls)
        => ExecuteUpdate(x => x.MediaTypeId == mediaTypeId , setPropertyCalls);
}
#endregion MediaTypeDao

 #region PlaylistDao
/// <summary>
/// Playlist 데이터 클래스
/// </summary>
public partial class PlaylistDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Playlist GetByKey(int playlistId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Playlist>().FirstOrDefault(x =>  x.PlaylistId == playlistId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int playlistId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Playlist>().Count(x =>  x.PlaylistId == playlistId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="playlistId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int playlistId )
	{
        var entity = GetByKey(playlistId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int playlistId )
        => ExecuteDelete(x => x.PlaylistId == playlistId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int playlistId , Expression<Func<SetPropertyCalls<Playlist>, SetPropertyCalls<Playlist>>> setPropertyCalls)
        => ExecuteUpdate(x => x.PlaylistId == playlistId , setPropertyCalls);
}
#endregion PlaylistDao

 #region PlaylistTrackDao
/// <summary>
/// PlaylistTrack 데이터 클래스
/// </summary>
public partial class PlaylistTrackDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
/// <param name="trackId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public PlaylistTrack GetByKey(int playlistId , int trackId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<PlaylistTrack>().FirstOrDefault(x =>  x.PlaylistId == playlistId  &&  x.TrackId == trackId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
/// <param name="trackId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int playlistId , int trackId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == playlistId  &&  x.TrackId == trackId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int playlistId , int trackId )
	{
        var entity = GetByKey(playlistId , trackId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetByPlaylistId
    public List<PlaylistTrack> GetByPlaylistId(int playlistId)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToList();
    }
    
    public PlaylistTrack[] GetByPlaylistIdAsArray(int playlistId)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToArray();
    }
    
    public HashSet<PlaylistTrack> GetByPlaylistIdAsHastSet(int playlistId)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToHashSet();
    }
    
    public Dictionary<K, PlaylistTrack> GetByPlaylistIdAsDictionary<K>(int playlistId, Func<PlaylistTrack, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByPlaylistIdAsDictionary<K, E>(int playlistId, Func<PlaylistTrack, K> keySelector,Func<PlaylistTrack, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    
	#region GetByTrackId
    public List<PlaylistTrack> GetByTrackId(int trackId)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToList();
    }
    
    public PlaylistTrack[] GetByTrackIdAsArray(int trackId)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToArray();
    }
    
    public HashSet<PlaylistTrack> GetByTrackIdAsHastSet(int trackId)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToHashSet();
    }
    
    public Dictionary<K, PlaylistTrack> GetByTrackIdAsDictionary<K>(int trackId, Func<PlaylistTrack, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByTrackIdAsDictionary<K, E>(int trackId, Func<PlaylistTrack, K> keySelector,Func<PlaylistTrack, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int playlistId , int trackId )
        => ExecuteDelete(x => x.PlaylistId == playlistId && x.TrackId == trackId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int playlistId , int trackId , Expression<Func<SetPropertyCalls<PlaylistTrack>, SetPropertyCalls<PlaylistTrack>>> setPropertyCalls)
        => ExecuteUpdate(x => x.PlaylistId == playlistId && x.TrackId == trackId , setPropertyCalls);
}
#endregion PlaylistTrackDao

 #region PlaylistTrackHistoryDao
/// <summary>
/// PlaylistTrackHistory 데이터 클래스
/// </summary>
public partial class PlaylistTrackHistoryDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
/// <param name="trackId">기본키</param>
/// <param name="writtenAt">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public PlaylistTrackHistory GetByKey(int playlistId , int trackId , DateTime writtenAt )
	{
        using var context = DbContextFactory.Create();

        return context.Set<PlaylistTrackHistory>().FirstOrDefault(x =>  x.PlaylistId == playlistId  &&  x.TrackId == trackId  &&  x.WrittenAt == writtenAt );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
/// <param name="trackId">기본키</param>
/// <param name="writtenAt">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int playlistId , int trackId , DateTime writtenAt )
	{
        using var context = DbContextFactory.Create();

		return context.Set<PlaylistTrackHistory>().Count(x =>  x.PlaylistId == playlistId  &&  x.TrackId == trackId  &&  x.WrittenAt == writtenAt ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> /// <param name="writtenAt">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int playlistId , int trackId , DateTime writtenAt )
	{
        var entity = GetByKey(playlistId , trackId , writtenAt );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetByPlaylistId
    public List<PlaylistTrackHistory> GetByPlaylistId(int playlistId)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToList();
    }
    
    public PlaylistTrackHistory[] GetByPlaylistIdAsArray(int playlistId)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToArray();
    }
    
    public HashSet<PlaylistTrackHistory> GetByPlaylistIdAsHastSet(int playlistId)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToHashSet();
    }
    
    public Dictionary<K, PlaylistTrackHistory> GetByPlaylistIdAsDictionary<K>(int playlistId, Func<PlaylistTrackHistory, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByPlaylistIdAsDictionary<K, E>(int playlistId, Func<PlaylistTrackHistory, K> keySelector,Func<PlaylistTrackHistory, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByPlaylistIdCore(context, playlistId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    
	#region GetByTrackId
    public List<PlaylistTrackHistory> GetByTrackId(int trackId)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToList();
    }
    
    public PlaylistTrackHistory[] GetByTrackIdAsArray(int trackId)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToArray();
    }
    
    public HashSet<PlaylistTrackHistory> GetByTrackIdAsHastSet(int trackId)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToHashSet();
    }
    
    public Dictionary<K, PlaylistTrackHistory> GetByTrackIdAsDictionary<K>(int trackId, Func<PlaylistTrackHistory, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByTrackIdAsDictionary<K, E>(int trackId, Func<PlaylistTrackHistory, K> keySelector,Func<PlaylistTrackHistory, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByTrackIdCore(context, trackId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> /// <param name="writtenAt">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int playlistId , int trackId , DateTime writtenAt )
        => ExecuteDelete(x => x.PlaylistId == playlistId && x.TrackId == trackId && x.WrittenAt == writtenAt );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> /// <param name="writtenAt">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int playlistId , int trackId , DateTime writtenAt , Expression<Func<SetPropertyCalls<PlaylistTrackHistory>, SetPropertyCalls<PlaylistTrackHistory>>> setPropertyCalls)
        => ExecuteUpdate(x => x.PlaylistId == playlistId && x.TrackId == trackId && x.WrittenAt == writtenAt , setPropertyCalls);
}
#endregion PlaylistTrackHistoryDao

 #region TimeTableDao
/// <summary>
/// TimeTable 데이터 클래스
/// </summary>
public partial class TimeTableDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="time">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public TimeTable GetByKey(TimeOnly time )
	{
        using var context = DbContextFactory.Create();

        return context.Set<TimeTable>().FirstOrDefault(x =>  x.Time == time );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="time">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(TimeOnly time )
	{
        using var context = DbContextFactory.Create();

		return context.Set<TimeTable>().Count(x =>  x.Time == time ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="time">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(TimeOnly time )
	{
        var entity = GetByKey(time );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="time">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(TimeOnly time )
        => ExecuteDelete(x => x.Time == time );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="time">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(TimeOnly time , Expression<Func<SetPropertyCalls<TimeTable>, SetPropertyCalls<TimeTable>>> setPropertyCalls)
        => ExecuteUpdate(x => x.Time == time , setPropertyCalls);
}
#endregion TimeTableDao

 #region TrackDao
/// <summary>
/// Track 데이터 클래스
/// </summary>
public partial class TrackDao
{
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="trackId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public Track GetByKey(int trackId )
	{
        using var context = DbContextFactory.Create();

        return context.Set<Track>().FirstOrDefault(x =>  x.TrackId == trackId );
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="trackId">기본키</param>
	/// <returns>존재 여부</returns>
    public bool ExistsByKey(int trackId )
	{
        using var context = DbContextFactory.Create();

		return context.Set<Track>().Count(x =>  x.TrackId == trackId ) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="trackId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public int DeleteByKey(int trackId )
	{
        var entity = GetByKey(trackId );

        if (entity == null)
            return 0;

        return Delete(entity);
	}
	
	
	#region GetByAlbumId
    public List<Track> GetByAlbumId(int? albumId)
    {
        using var context = DbContextFactory.Create();

        return GetByAlbumIdCore(context, albumId).ToList();
    }
    
    public Track[] GetByAlbumIdAsArray(int? albumId)
    {
        using var context = DbContextFactory.Create();

        return GetByAlbumIdCore(context, albumId).ToArray();
    }
    
    public HashSet<Track> GetByAlbumIdAsHastSet(int? albumId)
    {
        using var context = DbContextFactory.Create();

        return GetByAlbumIdCore(context, albumId).ToHashSet();
    }
    
    public Dictionary<K, Track> GetByAlbumIdAsDictionary<K>(int? albumId, Func<Track, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByAlbumIdCore(context, albumId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByAlbumIdAsDictionary<K, E>(int? albumId, Func<Track, K> keySelector,Func<Track, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByAlbumIdCore(context, albumId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    
	#region GetByGenreId
    public List<Track> GetByGenreId(int genreId)
    {
        using var context = DbContextFactory.Create();

        return GetByGenreIdCore(context, genreId).ToList();
    }
    
    public Track[] GetByGenreIdAsArray(int genreId)
    {
        using var context = DbContextFactory.Create();

        return GetByGenreIdCore(context, genreId).ToArray();
    }
    
    public HashSet<Track> GetByGenreIdAsHastSet(int genreId)
    {
        using var context = DbContextFactory.Create();

        return GetByGenreIdCore(context, genreId).ToHashSet();
    }
    
    public Dictionary<K, Track> GetByGenreIdAsDictionary<K>(int genreId, Func<Track, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByGenreIdCore(context, genreId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByGenreIdAsDictionary<K, E>(int genreId, Func<Track, K> keySelector,Func<Track, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByGenreIdCore(context, genreId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    
	#region GetByMediaTypeId
    public List<Track> GetByMediaTypeId(int mediaTypeId)
    {
        using var context = DbContextFactory.Create();

        return GetByMediaTypeIdCore(context, mediaTypeId).ToList();
    }
    
    public Track[] GetByMediaTypeIdAsArray(int mediaTypeId)
    {
        using var context = DbContextFactory.Create();

        return GetByMediaTypeIdCore(context, mediaTypeId).ToArray();
    }
    
    public HashSet<Track> GetByMediaTypeIdAsHastSet(int mediaTypeId)
    {
        using var context = DbContextFactory.Create();

        return GetByMediaTypeIdCore(context, mediaTypeId).ToHashSet();
    }
    
    public Dictionary<K, Track> GetByMediaTypeIdAsDictionary<K>(int mediaTypeId, Func<Track, K> keySelector)
    {
        using var context = DbContextFactory.Create();

        return GetByMediaTypeIdCore(context, mediaTypeId).ToDictionary(keySelector);
    }
    
    public Dictionary<K, E> GetByMediaTypeIdAsDictionary<K, E>(int mediaTypeId, Func<Track, K> keySelector,Func<Track, E> elementSelector)
    {
        using var context = DbContextFactory.Create();

        return GetByMediaTypeIdCore(context, mediaTypeId).ToDictionary(keySelector, elementSelector);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="trackId">기본키</param> 
    /// <returns></returns>
    public int ExecuteDeleteByKey(int trackId )
        => ExecuteDelete(x => x.TrackId == trackId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="trackId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public int ExecuteUpdateByKey(int trackId , Expression<Func<SetPropertyCalls<Track>, SetPropertyCalls<Track>>> setPropertyCalls)
        => ExecuteUpdate(x => x.TrackId == trackId , setPropertyCalls);
}
#endregion TrackDao


