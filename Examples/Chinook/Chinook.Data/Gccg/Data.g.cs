// <auto-generated> This file has been generated by Gccg</auto-generated>

#region usings
using System.ComponentModel;
using System.ComponentModel.DataAnnotations.Schema;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.Json.Serialization;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using Microsoft.Extensions.Logging;
#endregion

namespace Chinook.Data;

#region IEntity
public partial interface IEntity
{
}
#endregion IEntity

#region Untyped Entity
/// <summary>
///   모든 엔터티 클래스의 부모 클래스
/// </summary>
public abstract partial class UntypedEntity : IEntity
{
	/// <summary>
	///   부가정보를 저장하기 위한 object 객체
	/// </summary>
	[NotMapped]
	[JsonIgnore]
	public object EntityTag { get; set; }

	/// <summary>
	///   모든 속성의 값을 초기화한다.string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
	/// </summary>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear()
	{
		Clear(string.Empty, DateTime.Today);
	}

	/// <summary>
	///   모든 속성의 값을 초기화한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear(DateTime defaultDateTime)
	{
		Clear(string.Empty, defaultDateTime);
	}

	/// <summary>
	///   모든 속성의 값을 초기화한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultString"> 기본 string 값 </param>
	/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear(string defaultString, DateTime defaultDateTime)
	{
		Type type = GetType();
		PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

		foreach (PropertyInfo propertyInfo in propertyInfoArray)
		{
			if (propertyInfo.CanWrite == false)
				continue;

			if (propertyInfo.PropertyType == typeof (string))
				propertyInfo.SetValue(this, defaultString, null);

			else if (propertyInfo.PropertyType == typeof (DateTime))
				propertyInfo.SetValue(this, defaultDateTime, null);
		}
	}

	/// <summary>
	///   기본키 값들을 구분자(":")로 연결하여 반환한다.
	/// </summary>
	/// <returns> </returns>
	[JsonIgnore]
	public abstract string PrimaryKeyValues {get;}

	/// <summary>
	/// 엔터티를 대표하는 문자열을 구한다.
	/// </summary>
	[JsonIgnore]
	public abstract string EntityText { get; }

	/// <summary>
	///   엔터티의 이름을 구한다.
	/// </summary>
	public abstract string GetEntityTypeName();

	partial void IsLogWritable(ref bool? logWritable);

	[JsonIgnore]
	public virtual bool LogWritable
	{
		get
		{
		bool? logWritable = null;
		IsLogWritable(ref logWritable);

		if (logWritable.HasValue)
			return logWritable.Value;

		return false;
		}
	}

	/// <summary>
	///   EntityLog에 찍힐 문자열을 구한다. Code로 끝나는 코드 프로퍼티의 경우 대응하는 문자열 프로퍼티의 값도 추가한다.
	///   주의) EntityLog 테이블의 설계 상 최대 2000자 까지만 저장할 수 있음.
	/// </summary>
	/// <returns> </returns>
	public virtual string ToEntityLog()
	{
		const int MaxLength = 2000; // 최대 2000자 까지만 저장.

		Type type = GetType();

		var propertyInfoes = type.GetProperties();

		StringBuilder builder = new StringBuilder(ToString());

		builder.AppendLine();
		foreach (var propertyInfo in propertyInfoes)
		{
			if (propertyInfo.PropertyType != typeof (int))
				continue;

			if (propertyInfo.Name.EndsWith("Code") == false)
				continue;

			string textPropertyName = propertyInfo.Name.Substring(0, propertyInfo.Name.Length - 4) + "Text";
			string textValue = GetTextFromCodeProperty(this, type, textPropertyName);

			if (textValue != null)
				builder.AppendFormat("[{0}] {1}{2}", textPropertyName, textValue, Environment.NewLine);
		}

		if (builder.Length > MaxLength)
			return builder.ToString(0, MaxLength);
		else
			return builder.ToString();
	}

	private static string GetTextFromCodeProperty(object entity, Type objectType, string textPropertyName)
	{
		var propertyInfo = objectType.GetProperty(textPropertyName);
		object propertyValue = propertyInfo.GetValue(entity, null);

		if (propertyValue is string)
			return (string) propertyValue;
		else
			return null;
	}
	
	public abstract void ClearKeyValues();
}
#endregion Untyped Entity

#region Entity<T>
/// <summary>
/// 모든 엔터티 클래스의 형이 지정된 부모 클래스
/// </summary>
/// <typeparam name="T">엔터티 클래스의 형식</typeparam>
public abstract partial class Entity<T> : UntypedEntity, IEditableObject where T : class, new()
{
	/// <summary>
	/// 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public abstract T Clone();

	#region Implementation of IEditableObject

	protected T _clone = null;

	/// <summary>
	/// IEditableObject.BeginEdit 구현
	/// </summary>
	public void BeginEdit()
	{
		if (_clone == null)
			_clone = Clone();
	}

	/// <summary>
	/// IEditableObject.EndEdit 구현
	/// </summary>
	public void EndEdit()
	{
		_clone = null;
	}

	public abstract void CancelEdit();

	#endregion

	/// <summary>
	/// 객체에 감사정보를 기입한다. 보통 ModifiedAt, ModifiedBy 등의 속성을 기록함.
	/// </summary>
    protected internal virtual partial void WriteAuditInfo();
}

#endregion Entity<T>

#region PropertyChangedEventArgs
/// <summary>
/// 속성 값이 변경된 후 발생하는 이벤트의 매개변수 클래스
/// </summary>
/// <typeparam name="T"></typeparam>
internal class PropertyChangedEventArgs<T> : EventArgs where T : Entity<T>, new()
{
	/// <summary>
	/// 속성 값이 변경된 엔티티
	/// </summary>
	public T Entity { get; set; }

	public PropertyChangedEventArgs(T entity)
	{
		Entity = entity;
	}
}

/// <summary>
/// 속성 값이 변경되기 전 발생하는 이벤트의 매개변수 클래스
/// </summary>
/// <typeparam name="T"></typeparam>
/// <typeparam name="K"></typeparam>
internal class PropertyChangingEventArgs<T, K> : EventArgs where T : Entity<T>, new()
{
	/// <summary>
	/// 속성 값이 변경될 엔티티
	/// </summary>
	public T Entity { get; set; }

	/// <summary>
	/// 새로 변경 될 속성 값
	/// </summary>
	public K Value { get; set; }

	public PropertyChangingEventArgs(T entity, K value)
	{
		Entity = entity;
		Value = value;
	}
}
#endregion

#region EntityDao<T>
public abstract partial class EntityDao<T> where T : Entity<T>, new()
{
	internal EntityDao() { }

	#region Create
	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
	/// </summary>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create()
	{
		return Create(string.Empty, DateTime.Today);
	}

	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultDateTime">기본 DateTime 값</param>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create(DateTime defaultDateTime)
	{
		return Create(string.Empty, defaultDateTime);
	}

	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultString">기본 string 값</param>
	/// <param name="defaultDateTime">기본 DateTime 값</param>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create(string defaultString, DateTime defaultDateTime)
	{
		T entity = new T();
		entity.Clear(defaultString, defaultDateTime);

		return entity;
	}
	#endregion Create

    #region Get
    /// <summary>
    /// 모든 엔터티를 반환한다.
    /// </summary>
    /// <returns>엔터티의 리스트</returns>
    public virtual async Task<List<T>> Get()
        => await Get<T>(null, null, true, 0, int.MaxValue);

    /// <summary>
    /// 조건식에 맞는 엔터티들을 반환한다.
    /// </summary>
    /// <param name="where">조건식</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual async Task<List<T>> Get(Expression<Func<T, bool>> where)
        => await Get<T>(where, null, true, 0, int.MaxValue);

    /// <summary>
    /// 모든 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual async Task<List<T>> Get<O>(Expression<Func<T, O>> orderBy, bool ascending)
        => await Get<O>(null, orderBy, ascending, 0, int.MaxValue);

    /// <summary>
    /// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
    /// <param name="maximumRows">반환할 엔터티의 갯수</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual Task<List<T>> Get<O>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex,
        int maximumRows)
        => Get(null, orderBy, ascending, startRowIndex, maximumRows);

    /// <summary>
    /// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual Task<List<T>> Get<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy,
        bool ascending)
        => Get(where, orderBy, ascending, 0, int.MaxValue);

    /// <summary>
    /// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
    /// <param name="maximumRows">반환할 엔터티의 갯수</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual async Task<List<T>> Get<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows)
    {
        await using var context = DbContextFactory.Create();

        return await GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToListAsync();
    }
    #endregion Get

	#region select
	/// <summary>
	///   모든 선택식의 결과를 반환한다.
	/// </summary>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<S>(Expression<Func<T, S>> select)
        => Select<T, S>(null, null, true, 0, int.MaxValue, select);

	/// <summary>
	///   조건식에 맞는 선택식의 결과를 반환한다.
	/// </summary>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select)
        => Select<T, S>(where, null, true, 0, int.MaxValue, select);

	/// <summary>
	///   모든 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="O"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<O, S>(Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
        => Select(null, orderBy, ascending, 0, int.MaxValue, select);

	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="O"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
	/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<O, S>(Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
        => Select(null, orderBy, ascending, startRowIndex, maximumRows, select);
		
	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="O"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual Task<List<S>> Select<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, Expression<Func<T, S>> select)
        => Select(where, orderBy, ascending, 0, int.MaxValue, select);

	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징과 프로젝션을을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="O"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="S"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
	/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual async Task<List<S>> Select<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, S>> select)
    {
        await using var context = DbContextFactory.Create();

        var query = GetListCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
        return await query.Select(select).ToListAsync();
    }

	private static IQueryable<T> GetListCore<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, int startRowIndex, int maximumRows, DbContext context)
	{
		var query = from x in context.Set<T>()
					select x;

		if (where != null)
			query = query.Where(where);

		IOrderedQueryable<T> orderedQuery = null;

		if (orderBy != null)
			orderedQuery = (ascending) ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

		if (startRowIndex != 0 || maximumRows != int.MaxValue)
		{
			if (orderedQuery != null)
				orderedQuery = (IOrderedQueryable<T>)orderedQuery.Skip(startRowIndex).Take(maximumRows);
			else
				query = query.Skip(startRowIndex).Take(maximumRows);
		}

		return orderedQuery ?? query;
	}
	#endregion select

	#region GetFirst / GetLast
    /// <summary>
    /// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <returns>엔터티</returns>
    public virtual Task<T> GetFirst(CancellationToken ctk = default)
        => GetScalr<T>(null, null, true, ctk);

	/// <summary>
	/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <param name="where">조건식</param>
	/// <returns>엔터티</returns>
    public virtual Task<T> GetFirst(Expression<Func<T, bool>> where, CancellationToken ctk = default) 
        => GetScalr<T>(where, null, true, ctk);

    /// <summary>
	/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="orderBy">정렬식</param>
	/// <returns>엔터티</returns>
    public virtual Task<T> GetFirst<O>(Expression<Func<T, O>> orderBy, CancellationToken ctk = default)
        => GetScalr<O>(null, orderBy, true, ctk);

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <returns>엔터티</returns>
    public virtual Task<T> GetFirst<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, CancellationToken ctk = default)
        => GetScalr(where, orderBy, true, ctk);

	private async Task<T> GetScalr<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, CancellationToken ctk)
	{
        await using var context = DbContextFactory.Create();

	    return await GetScalarCore(where, orderBy, ascending, context).FirstOrDefaultAsync(ctk);
	}

    /// <summary>
    /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <returns>엔터티</returns>
    public virtual Task<T> GetLast<O>(Expression<Func<T, O>> orderBy, CancellationToken ctk = default)
        => GetScalr(null, orderBy, false, ctk);

	/// <summary>
	/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="orderBy">정렬식</param>
	/// <returns>엔터티</returns>
    public virtual Task<T> GetLast<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, CancellationToken ctk = default)
        => GetScalr(where, orderBy, false, ctk);

    private static IQueryable<T> GetScalarCore<O>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, bool ascending, DbContext context)
	{
		var query = from x in context.Set<T>()
					select x;

		if (where != null)
			query = query.Where(where);

        // 마지막 행은 orderby가 반드시 지정되어 있어야 함. orderby를 지정하지 않으면 skip 메서드를 사용할 수 없기 때문.
        if (orderBy != null)
			query = @ascending ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

        return query;
	}
	#endregion GetFirst / GetLast

	#region SelectFirst / SelectLast
	/// <summary>
	/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual Task<S> SelectFirst<S>(Expression<Func<T, S>> select, CancellationToken ctk = default)
        => SelectScalar<T, S>(null, null, select, false, ctk);

	/// <summary>
	/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="S">선택 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual Task<S> SelectFirst<S>(Expression<Func<T, bool>> where, Expression<Func<T, S>> select, CancellationToken ctk = default)
        => SelectScalar<T, S>(where, null, select, false, ctk);

	/// <summary>
	/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
	/// <typeparam name="S">선택 형식</typeparam>
	/// <param name="orderBy">정렬식</param>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual Task<S> SelectFirst<O, S>(Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select, CancellationToken ctk = default)
        => SelectScalar(null, orderBy, select, true, ctk);

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="S">선택 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <returns>엔터티</returns>
    public virtual Task<S> SelectFirst<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select, CancellationToken ctk = default)
        => SelectScalar(where, orderBy, select, true, ctk);

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="S">선택 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <returns>엔터티</returns>
    private async Task<S> SelectScalar<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select, bool ascending, CancellationToken ctk)
	{
        await using var context = DbContextFactory.Create();

		var query = GetScalarCore(where, orderBy, ascending, context);
		return await query.Select(select).FirstOrDefaultAsync();
	}

    /// <summary>
    /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="S">선택 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <returns>엔터티</returns>
    public virtual Task<S> SelectLast<O, S>(Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select, CancellationToken ctk = default)
        => SelectScalar(null, orderBy, select, false, ctk);

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="O">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="S">선택 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <returns>엔터티</returns>
    public virtual Task<S> SelectLast<O, S>(Expression<Func<T, bool>> where, Expression<Func<T, O>> orderBy, Expression<Func<T, S>> select, CancellationToken ctk = default)
        => SelectScalar(where, orderBy, select, false, ctk);
    #endregion SelectFirst / SelectLast

	#region GetCount
	/// <summary>
	/// 모든 엔터티의 갯수를 구한다.
	/// </summary>
	/// <returns>엔터티의 갯수</returns>
    public virtual Task<int> GetCount(CancellationToken ctk = default)
        => GetCount(null);

    /// <summary>
    /// 조건식에 맞는 엔터티의 갯수를 구한다.
    /// </summary>
    /// <param name="where">조건식</param>
    /// <returns>엔터티의 갯수</returns>
    public virtual async Task<int> GetCount(Expression<Func<T, bool>> where, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        var query = MakeCountQuery(where, context);
        return await query.CountAsync(ctk);
    }

    private IQueryable<T> MakeCountQuery(Expression<Func<T, bool>> where, DbContext context)
    {
        var query = from item in context.Set<T>()
            select item;

        if (where != null)
            query = query.Where(where);

        return query;
    }
	#endregion GetCount

	#region Exist
	/// <summary>
	/// 조건식에 맞는 엔터티가 존재하는지 검사한다.
	/// </summary>
	/// <param name="where">조건식</param>
	/// <returns>존재 여부</returns>
    public virtual async Task<bool> Exists(Expression<Func<T, bool>> where, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        var query = MakeCountQuery(where, context);
        return await query.AnyAsync();
    }
	#endregion Exist

	#region Write log partial methods
	protected virtual partial void OnSaving(T entity, LogType logType);

	/// <summary>
	/// 엔티티의 로그를 기록한다.
	/// </summary>
	/// <param name="entity">엔티티</param>
	/// <param name="logType">로그 타입</param>
	protected virtual partial void OnSaved(T entity, LogType logType);
	#endregion Write log partial methods

	#region Insert / Update / Delete
    internal virtual void MarkToSave(DbContext context, LogType logType, T entity)
    {
        OnSaving(entity, logType);

        context.Entry(entity).State = logType switch
        {
            LogType.Insert => EntityState.Added,
            LogType.Update => EntityState.Modified,
            LogType.Delete => EntityState.Deleted,
			_ => throw new ArgumentOutOfRangeException(nameof(logType), logType, null)
        };
    }
    
    internal async Task<(int Count, T Entity)> SaveChanges(LogType logType, CancellationToken ctk, params IEnumerable<T> entities)
	{
        await using var context = DbContextFactory.Create();

        foreach (var entity in entities)
    		MarkToSave(context, logType, entity);
			
		int count = await context.SaveChangesAsync(ctk);
		if (count > 0)
            foreach (var entity in entities)
    			OnSaved(entity, logType);

        return (count, count > 0 ? entities.First() : null);
	}

	public virtual async Task<T> Insert(T entity, CancellationToken ctk = default)
        => (await SaveChanges(LogType.Insert, ctk, entity)).Entity;

	public virtual async Task<int> InsertMany(IEnumerable<T> entities, CancellationToken ctk = default)
        => (await SaveChanges(LogType.Insert, ctk, entities)).Count;

	public virtual async Task<int> Update(T entity, CancellationToken ctk = default) 
        => (await SaveChanges(LogType.Update, ctk, entity)).Count;

	public virtual async Task<int> UpdateMany(IEnumerable<T> entities, CancellationToken ctk = default) 
        => (await SaveChanges(LogType.Update, ctk, entities)).Count;

	public virtual async Task<int> Delete(T entity, CancellationToken ctk = default) 
        => (await SaveChanges(LogType.Delete, ctk, entity)).Count;

	public virtual async Task<int> DeleteMany(IEnumerable<T> entities, CancellationToken ctk = default) 
        => (await SaveChanges(LogType.Delete, ctk, entities)).Count;

	public virtual async Task<int> DeleteAll(Expression<Func<T, bool>> where, CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		var entities = await Get(where);

        return await DeleteMany(entities, ctk);
	}

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
    /// <returns>삽입된 엔터티</returns>
    public virtual async Task<T> InsertIfNotExist(T entity, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        int count = await context.Set<T>().CountAsync(HasSameKey(entity), ctk);
        if (count > 0)
            return null;

        return await Insert(entity, ctk);
    }

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
    /// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
    /// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual async Task<bool> InsertOrUpdate(T entity, bool withAudit = false, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        int count = await context.Set<T>().CountAsync(HasSameKey(entity), ctk);
        if (count > 0)
        {
            await Update(entity, ctk);
            return false;
        }
        else
        {
            await Insert(entity, ctk);
            return true;
        }
    }	
	#endregion Insert / Update / Delete

    #region ExecuteUpdate / ExecuteDelete
    /// <summary>
    /// 조건식을 만족하는 엔티티를 일괄 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="predicate">조건식</param>
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. 예)p => p.TypeCode, p => p.TypeCode + 1</param>
    /// <returns></returns>
    public async Task<int> ExecuteUpdate(Expression<Func<T, bool>> predicate, Expression<Func<SetPropertyCalls<T>, SetPropertyCalls<T>>> setPropertyCalls, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await context.Set<T>().Where(predicate).ExecuteUpdateAsync(setPropertyCalls, ctk);
    }

    /// <summary>
    /// 조건식을 만족하는 엔티티를 일괄 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="predicate">조건식</param>
    /// <returns></returns>
    public async Task<int> ExecuteDelete(Expression<Func<T, bool>> predicate, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await context.Set<T>().Where(predicate).ExecuteDeleteAsync(ctk);
    }
    #endregion ExecuteUpdate / ExecuteDelete

    protected abstract Expression<Func<T, bool>> HasSameKey(T other);
}
#endregion EntityDao

#region Types
/// <summary>
/// 엔티티를 추가/수정/삭제 할 때 기록하는 로그의 종류
/// </summary>
public enum LogType
{
	/// <summary>
	/// 엔티티 삽입
	/// </summary>
	Insert,
	/// <summary>
	/// 엔티티 갱신
	/// </summary>
	Update,
	/// <summary>
	/// 엔티티 삭제
	/// </summary>
	Delete
}
#endregion

#region DaoBase
/// <summary>
/// Dao의 부모. Dao를 확장하는 용도로 사용한다.
/// </summary>
public partial class DaoBase
{
}
#endregion

#region ChinookContextLoggerFactory
/// <summary>
/// 간단하게 사용할 수 있는 엔터티 프레임워크 코어용 로거 팩토리. Console과 Debug의 출력창 혹은 파일에 저장 할 수 있음
/// </summary>
internal class ChinookContextLoggerFactory : LoggerFactory
{
    #region singleton
    private static ChinookContextLoggerFactory _instance;

    public static ChinookContextLoggerFactory GetInstance(params LogPath[] loggerTypes) => GetInstance(loggerTypes.Select(x => x.ToString()).ToArray());

    public static ChinookContextLoggerFactory GetInstance(params string[] logPathes)
    {
        if (_instance == null)
        {
            List<ILoggerProvider> logProviders = new List<ILoggerProvider>(logPathes.Select(x => new LogProvider(x)));
            _instance = new ChinookContextLoggerFactory(logProviders);
        }

        return _instance;
    }

    private ChinookContextLoggerFactory(List<ILoggerProvider> providers) : base(providers)
    {
    }

    #endregion singleton

    internal class LogProvider : ILoggerProvider
    {
        public LogProvider(string logPath) => _logPath = logPath;

        private string _logPath;

        public void Dispose()
        {
        }

        public ILogger CreateLogger(string categoryName)
        {
            return new Logger(categoryName, _logPath);
        }
    }

    internal class Logger : ILogger
    {
        private readonly IWriter _writer;

        private readonly string _categoryName;

        public Logger(string categoryName, string logPath)
        {
            _categoryName = categoryName;

            _writer = logPath switch
            {
                nameof(LogPath.Console) => new ConsoleWriter(),
                nameof(LogPath.Debug) => new DebugWriter(),
                _ => new FileWriter(logPath),
            };

            if (_counters.ContainsKey(_writer.UniqueName) is false)
                _counters.TryAdd(_writer.UniqueName, 0);
        }

        private static System.Collections.Concurrent.ConcurrentDictionary<string, int> _counters = new();

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
        {
            _writer.Open();
            _writer.WriteLine($"[{_counters[_writer.UniqueName]++:N0}] {DateTime.Now:s}");
            _writer.WriteLine(formatter(state, exception));
            _writer.WriteLine("--------------------------------------------------");
            _writer.WriteLine(Environment.NewLine);
            _writer.Save();
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return logLevel == LogLevel.Information &&
                    _categoryName == DbLoggerCategory.Database.Command.Name;
        }

        public IDisposable BeginScope<TState>(TState state)
        {
            return null;
        }
    }

    public interface IWriter
    {
        string UniqueName { get; }

        void WriteLine(string format, params object[] args);

        void Open()
        {
        }

        void Save()
        {
        }
    }

    internal class ConsoleWriter : IWriter
    {
        public string UniqueName => nameof(ConsoleWriter);

        public void WriteLine(string format, params object[] args) => Console.WriteLine(format, args);
    }

    internal class DebugWriter : IWriter
    {
        public string UniqueName => nameof(DebugWriter);

        public void WriteLine(string format, params object[] args) => Debug.WriteLine(format, args);
    }

    internal class FileWriter : IWriter
    {
        private readonly string _logFilePath;

        public string UniqueName => _logFilePath;

        public FileWriter(string logFilePath)
        {
            _logFilePath = logFilePath;
        }

        private readonly StringBuilder _builder = new StringBuilder();

        public void WriteLine(string format, params object[] args)
        {
            _builder.AppendFormat(format, args);
            _builder.AppendLine();
        }

        public void Open()
        {
            _builder.Clear();
        }

        public void Save()
        {
            File.AppendAllText(_logFilePath, _builder.ToString());
        }
    }
}

internal enum LogPath
{
    /// <summary>
    /// 콘솔에 출력
    /// </summary>
    Console,
    /// <summary>
    /// 디버거 창에 출력
    /// </summary>
    Debug,
}
#endregion ChinookContextLoggerFactory

#region Entities
 #region Album
/// <summary>
/// Album 엔터티
/// </summary>
public partial class Album : Entity<Album>, IEntity
{
	public const string EntityTypeName = "Album";

	public static void Copy(Album source, Album target)
	{
		target.AlbumId = source.AlbumId; 		
target.ArtistId = source.ArtistId; 		
target.Title = source.Title; 		
target.TypeCode = source.TypeCode; 
	}

	/// <summary>
	/// Album 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Album Clone()
	{
		var clone = new Album();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Album 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[AlbumId]" + AlbumId  + ", " + "[ArtistId]" + ArtistId  + ", " + "[Title]" + Title  + ", " + "[TypeCode]" + TypeCode ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", AlbumId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		AlbumId = default;
	}
}

/// <summary>
/// Album 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum AlbumColumn
{
	AlbumId ,
ArtistId ,
Title ,
TypeCode 
}

/// <summary>
/// Album 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Album&gt; 구현)
/// </summary>
public class AlbumEqualityComparer : IEqualityComparer<Album>
{
    #region singleton
    private static readonly Lazy<AlbumEqualityComparer> _instance = new(() => new AlbumEqualityComparer());

    public static AlbumEqualityComparer Instance => _instance.Value;

    private AlbumEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Album x, Album y)
	{
		return x.AlbumId == y.AlbumId ;
	}

	public int GetHashCode(Album obj)
	{
		return obj.AlbumId.GetHashCode() ;
	}
}
#endregion Album

 #region Artist
/// <summary>
/// Artist 엔터티
/// </summary>
public partial class Artist : Entity<Artist>, IEntity
{
	public const string EntityTypeName = "Artist";

	public static void Copy(Artist source, Artist target)
	{
		target.ArtistId = source.ArtistId; 		
target.Name = source.Name; 		
target.TypeCode = source.TypeCode; 
	}

	/// <summary>
	/// Artist 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Artist Clone()
	{
		var clone = new Artist();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Artist 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[ArtistId]" + ArtistId  + ", " + "[Name]" + Name  + ", " + "[TypeCode]" + TypeCode ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", ArtistId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		ArtistId = default;
	}
}

/// <summary>
/// Artist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum ArtistColumn
{
	ArtistId ,
Name ,
TypeCode 
}

/// <summary>
/// Artist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Artist&gt; 구현)
/// </summary>
public class ArtistEqualityComparer : IEqualityComparer<Artist>
{
    #region singleton
    private static readonly Lazy<ArtistEqualityComparer> _instance = new(() => new ArtistEqualityComparer());

    public static ArtistEqualityComparer Instance => _instance.Value;

    private ArtistEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Artist x, Artist y)
	{
		return x.ArtistId == y.ArtistId ;
	}

	public int GetHashCode(Artist obj)
	{
		return obj.ArtistId.GetHashCode() ;
	}
}
#endregion Artist

 #region Code
/// <summary>
/// Code 엔터티
/// </summary>
public partial class Code : Entity<Code>, IEntity
{
	public const string EntityTypeName = "Code";

	public static void Copy(Code source, Code target)
	{
		target.CodeId = source.CodeId; 		
target.CodeCategoryId = source.CodeCategoryId; 		
target.Memo = source.Memo; 		
target.Text = source.Text; 
	}

	/// <summary>
	/// Code 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Code Clone()
	{
		var clone = new Code();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Code 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[CodeId]" + CodeId  + ", " + "[CodeCategoryId]" + CodeCategoryId  + ", " + "[Memo]" + Memo  + ", " + "[Text]" + Text ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", CodeId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		CodeId = default;
	}
}

/// <summary>
/// Code 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum CodeColumn
{
	CodeId ,
CodeCategoryId ,
Memo ,
Text 
}

/// <summary>
/// Code 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Code&gt; 구현)
/// </summary>
public class CodeEqualityComparer : IEqualityComparer<Code>
{
    #region singleton
    private static readonly Lazy<CodeEqualityComparer> _instance = new(() => new CodeEqualityComparer());

    public static CodeEqualityComparer Instance => _instance.Value;

    private CodeEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Code x, Code y)
	{
		return x.CodeId == y.CodeId ;
	}

	public int GetHashCode(Code obj)
	{
		return obj.CodeId.GetHashCode() ;
	}
}
#endregion Code

 #region CodeCategory
/// <summary>
/// CodeCategory 엔터티
/// </summary>
public partial class CodeCategory : Entity<CodeCategory>, IEntity
{
	public const string EntityTypeName = "CodeCategory";

	public static void Copy(CodeCategory source, CodeCategory target)
	{
		target.CodeCategoryId = source.CodeCategoryId; 		
target.Name = source.Name; 
	}

	/// <summary>
	/// CodeCategory 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override CodeCategory Clone()
	{
		var clone = new CodeCategory();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// CodeCategory 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[CodeCategoryId]" + CodeCategoryId  + ", " + "[Name]" + Name ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", CodeCategoryId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		CodeCategoryId = default;
	}
}

/// <summary>
/// CodeCategory 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum CodeCategoryColumn
{
	CodeCategoryId ,
Name 
}

/// <summary>
/// CodeCategory 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;CodeCategory&gt; 구현)
/// </summary>
public class CodeCategoryEqualityComparer : IEqualityComparer<CodeCategory>
{
    #region singleton
    private static readonly Lazy<CodeCategoryEqualityComparer> _instance = new(() => new CodeCategoryEqualityComparer());

    public static CodeCategoryEqualityComparer Instance => _instance.Value;

    private CodeCategoryEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(CodeCategory x, CodeCategory y)
	{
		return x.CodeCategoryId == y.CodeCategoryId ;
	}

	public int GetHashCode(CodeCategory obj)
	{
		return obj.CodeCategoryId.GetHashCode() ;
	}
}
#endregion CodeCategory

 #region Customer
/// <summary>
/// Customer 엔터티
/// </summary>
public partial class Customer : Entity<Customer>, IEntity
{
	public const string EntityTypeName = "Customer";

	public static void Copy(Customer source, Customer target)
	{
		target.CustomerId = source.CustomerId; 		
target.Address = source.Address; 		
target.City = source.City; 		
target.Company = source.Company; 		
target.Country = source.Country; 		
target.Email = source.Email; 		
target.Fax = source.Fax; 		
target.FirstName = source.FirstName; 		
target.LastName = source.LastName; 		
target.Phone = source.Phone; 		
target.PostalCode = source.PostalCode; 		
target.State = source.State; 		
target.SupportRepId = source.SupportRepId; 
	}

	/// <summary>
	/// Customer 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Customer Clone()
	{
		var clone = new Customer();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Customer 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[CustomerId]" + CustomerId  + ", " + "[Address]" + Address  + ", " + "[City]" + City  + ", " + "[Company]" + Company  + ", " + "[Country]" + Country  + ", " + "[Email]" + Email  + ", " + "[Fax]" + Fax  + ", " + "[FirstName]" + FirstName  + ", " + "[LastName]" + LastName  + ", " + "[Phone]" + Phone  + ", " + "[PostalCode]" + PostalCode  + ", " + "[State]" + State  + ", " + "[SupportRepId]" + SupportRepId ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", CustomerId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		CustomerId = default;
	}
}

/// <summary>
/// Customer 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum CustomerColumn
{
	CustomerId ,
Address ,
City ,
Company ,
Country ,
Email ,
Fax ,
FirstName ,
LastName ,
Phone ,
PostalCode ,
State ,
SupportRepId 
}

/// <summary>
/// Customer 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Customer&gt; 구현)
/// </summary>
public class CustomerEqualityComparer : IEqualityComparer<Customer>
{
    #region singleton
    private static readonly Lazy<CustomerEqualityComparer> _instance = new(() => new CustomerEqualityComparer());

    public static CustomerEqualityComparer Instance => _instance.Value;

    private CustomerEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Customer x, Customer y)
	{
		return x.CustomerId == y.CustomerId ;
	}

	public int GetHashCode(Customer obj)
	{
		return obj.CustomerId.GetHashCode() ;
	}
}
#endregion Customer

 #region DateTable
/// <summary>
/// DateTable 엔터티
/// </summary>
public partial class DateTable : Entity<DateTable>, IEntity
{
	public const string EntityTypeName = "DateTable";

	public static void Copy(DateTable source, DateTable target)
	{
		target.Date = source.Date; 		
target.DateNull = source.DateNull; 
	}

	/// <summary>
	/// DateTable 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override DateTable Clone()
	{
		var clone = new DateTable();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// DateTable 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[Date]" + Date  + ", " + "[DateNull]" + DateNull ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", Date ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		Date = default;
	}
}

/// <summary>
/// DateTable 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum DateTableColumn
{
	Date ,
DateNull 
}

/// <summary>
/// DateTable 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;DateTable&gt; 구현)
/// </summary>
public class DateTableEqualityComparer : IEqualityComparer<DateTable>
{
    #region singleton
    private static readonly Lazy<DateTableEqualityComparer> _instance = new(() => new DateTableEqualityComparer());

    public static DateTableEqualityComparer Instance => _instance.Value;

    private DateTableEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(DateTable x, DateTable y)
	{
		return x.Date == y.Date ;
	}

	public int GetHashCode(DateTable obj)
	{
		return obj.Date.GetHashCode() ;
	}
}
#endregion DateTable

 #region Employee
/// <summary>
/// Employee 엔터티
/// </summary>
public partial class Employee : Entity<Employee>, IEntity
{
	public const string EntityTypeName = "Employee";

	public static void Copy(Employee source, Employee target)
	{
		target.EmployeeId = source.EmployeeId; 		
target.Address = source.Address; 		
target.BirthDate = source.BirthDate; 		
target.City = source.City; 		
target.Country = source.Country; 		
target.Email = source.Email; 		
target.Fax = source.Fax; 		
target.FirstName = source.FirstName; 		
target.HireDate = source.HireDate; 		
target.LastName = source.LastName; 		
target.Phone = source.Phone; 		
target.PostalCode = source.PostalCode; 		
target.ReportsTo = source.ReportsTo; 		
target.State = source.State; 		
target.Title = source.Title; 
	}

	/// <summary>
	/// Employee 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Employee Clone()
	{
		var clone = new Employee();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Employee 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[EmployeeId]" + EmployeeId  + ", " + "[Address]" + Address  + ", " + "[BirthDate]" + BirthDate  + ", " + "[City]" + City  + ", " + "[Country]" + Country  + ", " + "[Email]" + Email  + ", " + "[Fax]" + Fax  + ", " + "[FirstName]" + FirstName  + ", " + "[HireDate]" + HireDate  + ", " + "[LastName]" + LastName  + ", " + "[Phone]" + Phone  + ", " + "[PostalCode]" + PostalCode  + ", " + "[ReportsTo]" + ReportsTo  + ", " + "[State]" + State  + ", " + "[Title]" + Title ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", EmployeeId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		EmployeeId = default;
	}
}

/// <summary>
/// Employee 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum EmployeeColumn
{
	EmployeeId ,
Address ,
BirthDate ,
City ,
Country ,
Email ,
Fax ,
FirstName ,
HireDate ,
LastName ,
Phone ,
PostalCode ,
ReportsTo ,
State ,
Title 
}

/// <summary>
/// Employee 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Employee&gt; 구현)
/// </summary>
public class EmployeeEqualityComparer : IEqualityComparer<Employee>
{
    #region singleton
    private static readonly Lazy<EmployeeEqualityComparer> _instance = new(() => new EmployeeEqualityComparer());

    public static EmployeeEqualityComparer Instance => _instance.Value;

    private EmployeeEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Employee x, Employee y)
	{
		return x.EmployeeId == y.EmployeeId ;
	}

	public int GetHashCode(Employee obj)
	{
		return obj.EmployeeId.GetHashCode() ;
	}
}
#endregion Employee

 #region Genre
/// <summary>
/// Genre 엔터티
/// </summary>
public partial class Genre : Entity<Genre>, IEntity
{
	public const string EntityTypeName = "Genre";

	public static void Copy(Genre source, Genre target)
	{
		target.GenreId = source.GenreId; 		
target.Name = source.Name; 
	}

	/// <summary>
	/// Genre 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Genre Clone()
	{
		var clone = new Genre();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Genre 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[GenreId]" + GenreId  + ", " + "[Name]" + Name ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", GenreId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		GenreId = default;
	}
}

/// <summary>
/// Genre 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum GenreColumn
{
	GenreId ,
Name 
}

/// <summary>
/// Genre 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Genre&gt; 구현)
/// </summary>
public class GenreEqualityComparer : IEqualityComparer<Genre>
{
    #region singleton
    private static readonly Lazy<GenreEqualityComparer> _instance = new(() => new GenreEqualityComparer());

    public static GenreEqualityComparer Instance => _instance.Value;

    private GenreEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Genre x, Genre y)
	{
		return x.GenreId == y.GenreId ;
	}

	public int GetHashCode(Genre obj)
	{
		return obj.GenreId.GetHashCode() ;
	}
}
#endregion Genre

 #region Invoice
/// <summary>
/// Invoice 엔터티
/// </summary>
public partial class Invoice : Entity<Invoice>, IEntity
{
	public const string EntityTypeName = "Invoice";

	public static void Copy(Invoice source, Invoice target)
	{
		target.InvoiceId = source.InvoiceId; 		
target.BillingAddress = source.BillingAddress; 		
target.BillingCity = source.BillingCity; 		
target.BillingCountry = source.BillingCountry; 		
target.BillingPostalCode = source.BillingPostalCode; 		
target.BillingState = source.BillingState; 		
target.CustomerId = source.CustomerId; 		
target.InvoiceDate = source.InvoiceDate; 		
target.Total = source.Total; 
	}

	/// <summary>
	/// Invoice 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Invoice Clone()
	{
		var clone = new Invoice();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Invoice 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[InvoiceId]" + InvoiceId  + ", " + "[BillingAddress]" + BillingAddress  + ", " + "[BillingCity]" + BillingCity  + ", " + "[BillingCountry]" + BillingCountry  + ", " + "[BillingPostalCode]" + BillingPostalCode  + ", " + "[BillingState]" + BillingState  + ", " + "[CustomerId]" + CustomerId  + ", " + "[InvoiceDate]" + InvoiceDate  + ", " + "[Total]" + Total ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", InvoiceId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		InvoiceId = default;
	}
}

/// <summary>
/// Invoice 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum InvoiceColumn
{
	InvoiceId ,
BillingAddress ,
BillingCity ,
BillingCountry ,
BillingPostalCode ,
BillingState ,
CustomerId ,
InvoiceDate ,
Total 
}

/// <summary>
/// Invoice 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Invoice&gt; 구현)
/// </summary>
public class InvoiceEqualityComparer : IEqualityComparer<Invoice>
{
    #region singleton
    private static readonly Lazy<InvoiceEqualityComparer> _instance = new(() => new InvoiceEqualityComparer());

    public static InvoiceEqualityComparer Instance => _instance.Value;

    private InvoiceEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Invoice x, Invoice y)
	{
		return x.InvoiceId == y.InvoiceId ;
	}

	public int GetHashCode(Invoice obj)
	{
		return obj.InvoiceId.GetHashCode() ;
	}
}
#endregion Invoice

 #region InvoiceLine
/// <summary>
/// InvoiceLine 엔터티
/// </summary>
public partial class InvoiceLine : Entity<InvoiceLine>, IEntity
{
	public const string EntityTypeName = "InvoiceLine";

	public static void Copy(InvoiceLine source, InvoiceLine target)
	{
		target.InvoiceLineId = source.InvoiceLineId; 		
target.InvoiceId = source.InvoiceId; 		
target.Quantity = source.Quantity; 		
target.TrackId = source.TrackId; 		
target.UnitPrice = source.UnitPrice; 
	}

	/// <summary>
	/// InvoiceLine 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override InvoiceLine Clone()
	{
		var clone = new InvoiceLine();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// InvoiceLine 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[InvoiceLineId]" + InvoiceLineId  + ", " + "[InvoiceId]" + InvoiceId  + ", " + "[Quantity]" + Quantity  + ", " + "[TrackId]" + TrackId  + ", " + "[UnitPrice]" + UnitPrice ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", InvoiceLineId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		InvoiceLineId = default;
	}
}

/// <summary>
/// InvoiceLine 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum InvoiceLineColumn
{
	InvoiceLineId ,
InvoiceId ,
Quantity ,
TrackId ,
UnitPrice 
}

/// <summary>
/// InvoiceLine 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;InvoiceLine&gt; 구현)
/// </summary>
public class InvoiceLineEqualityComparer : IEqualityComparer<InvoiceLine>
{
    #region singleton
    private static readonly Lazy<InvoiceLineEqualityComparer> _instance = new(() => new InvoiceLineEqualityComparer());

    public static InvoiceLineEqualityComparer Instance => _instance.Value;

    private InvoiceLineEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(InvoiceLine x, InvoiceLine y)
	{
		return x.InvoiceLineId == y.InvoiceLineId ;
	}

	public int GetHashCode(InvoiceLine obj)
	{
		return obj.InvoiceLineId.GetHashCode() ;
	}
}
#endregion InvoiceLine

 #region MediaType
/// <summary>
/// MediaType 엔터티
/// </summary>
public partial class MediaType : Entity<MediaType>, IEntity
{
	public const string EntityTypeName = "MediaType";

	public static void Copy(MediaType source, MediaType target)
	{
		target.MediaTypeId = source.MediaTypeId; 		
target.Name = source.Name; 
	}

	/// <summary>
	/// MediaType 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override MediaType Clone()
	{
		var clone = new MediaType();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// MediaType 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[MediaTypeId]" + MediaTypeId  + ", " + "[Name]" + Name ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", MediaTypeId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		MediaTypeId = default;
	}
}

/// <summary>
/// MediaType 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum MediaTypeColumn
{
	MediaTypeId ,
Name 
}

/// <summary>
/// MediaType 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;MediaType&gt; 구현)
/// </summary>
public class MediaTypeEqualityComparer : IEqualityComparer<MediaType>
{
    #region singleton
    private static readonly Lazy<MediaTypeEqualityComparer> _instance = new(() => new MediaTypeEqualityComparer());

    public static MediaTypeEqualityComparer Instance => _instance.Value;

    private MediaTypeEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(MediaType x, MediaType y)
	{
		return x.MediaTypeId == y.MediaTypeId ;
	}

	public int GetHashCode(MediaType obj)
	{
		return obj.MediaTypeId.GetHashCode() ;
	}
}
#endregion MediaType

 #region Playlist
/// <summary>
/// Playlist 엔터티
/// </summary>
public partial class Playlist : Entity<Playlist>, IEntity
{
	public const string EntityTypeName = "Playlist";

	public static void Copy(Playlist source, Playlist target)
	{
		target.PlaylistId = source.PlaylistId; 		
target.Name = source.Name; 
	}

	/// <summary>
	/// Playlist 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Playlist Clone()
	{
		var clone = new Playlist();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Playlist 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[PlaylistId]" + PlaylistId  + ", " + "[Name]" + Name ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", PlaylistId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		PlaylistId = default;
	}
}

/// <summary>
/// Playlist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum PlaylistColumn
{
	PlaylistId ,
Name 
}

/// <summary>
/// Playlist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Playlist&gt; 구현)
/// </summary>
public class PlaylistEqualityComparer : IEqualityComparer<Playlist>
{
    #region singleton
    private static readonly Lazy<PlaylistEqualityComparer> _instance = new(() => new PlaylistEqualityComparer());

    public static PlaylistEqualityComparer Instance => _instance.Value;

    private PlaylistEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Playlist x, Playlist y)
	{
		return x.PlaylistId == y.PlaylistId ;
	}

	public int GetHashCode(Playlist obj)
	{
		return obj.PlaylistId.GetHashCode() ;
	}
}
#endregion Playlist

 #region PlaylistTrack
/// <summary>
/// PlaylistTrack 엔터티
/// </summary>
public partial class PlaylistTrack : Entity<PlaylistTrack>, IEntity
{
	public const string EntityTypeName = "PlaylistTrack";

	public static void Copy(PlaylistTrack source, PlaylistTrack target)
	{
		target.PlaylistId = source.PlaylistId; 		
target.TrackId = source.TrackId; 
	}

	/// <summary>
	/// PlaylistTrack 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override PlaylistTrack Clone()
	{
		var clone = new PlaylistTrack();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// PlaylistTrack 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[PlaylistId]" + PlaylistId  + ", " + "[TrackId]" + TrackId ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", PlaylistId , TrackId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		PlaylistId = default;
TrackId = default;
	}
}

/// <summary>
/// PlaylistTrack 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum PlaylistTrackColumn
{
	PlaylistId ,
TrackId 
}

/// <summary>
/// PlaylistTrack 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;PlaylistTrack&gt; 구현)
/// </summary>
public class PlaylistTrackEqualityComparer : IEqualityComparer<PlaylistTrack>
{
    #region singleton
    private static readonly Lazy<PlaylistTrackEqualityComparer> _instance = new(() => new PlaylistTrackEqualityComparer());

    public static PlaylistTrackEqualityComparer Instance => _instance.Value;

    private PlaylistTrackEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(PlaylistTrack x, PlaylistTrack y)
	{
		return x.PlaylistId == y.PlaylistId  && x.TrackId == y.TrackId ;
	}

	public int GetHashCode(PlaylistTrack obj)
	{
		return obj.PlaylistId.GetHashCode()  ^ obj.TrackId.GetHashCode() ;
	}
}
#endregion PlaylistTrack

 #region PlaylistTrackHistory
/// <summary>
/// PlaylistTrackHistory 엔터티
/// </summary>
public partial class PlaylistTrackHistory : Entity<PlaylistTrackHistory>, IEntity
{
	public const string EntityTypeName = "PlaylistTrackHistory";

	public static void Copy(PlaylistTrackHistory source, PlaylistTrackHistory target)
	{
		target.PlaylistId = source.PlaylistId; 		
target.TrackId = source.TrackId; 		
target.WrittenAt = source.WrittenAt; 		
target.Memo = source.Memo; 
	}

	/// <summary>
	/// PlaylistTrackHistory 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override PlaylistTrackHistory Clone()
	{
		var clone = new PlaylistTrackHistory();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// PlaylistTrackHistory 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[PlaylistId]" + PlaylistId  + ", " + "[TrackId]" + TrackId  + ", " + "[WrittenAt]" + WrittenAt  + ", " + "[Memo]" + Memo ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", PlaylistId , TrackId , WrittenAt ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		PlaylistId = default;
TrackId = default;
WrittenAt = default;
	}
}

/// <summary>
/// PlaylistTrackHistory 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum PlaylistTrackHistoryColumn
{
	PlaylistId ,
TrackId ,
WrittenAt ,
Memo 
}

/// <summary>
/// PlaylistTrackHistory 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;PlaylistTrackHistory&gt; 구현)
/// </summary>
public class PlaylistTrackHistoryEqualityComparer : IEqualityComparer<PlaylistTrackHistory>
{
    #region singleton
    private static readonly Lazy<PlaylistTrackHistoryEqualityComparer> _instance = new(() => new PlaylistTrackHistoryEqualityComparer());

    public static PlaylistTrackHistoryEqualityComparer Instance => _instance.Value;

    private PlaylistTrackHistoryEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(PlaylistTrackHistory x, PlaylistTrackHistory y)
	{
		return x.PlaylistId == y.PlaylistId  && x.TrackId == y.TrackId  && x.WrittenAt == y.WrittenAt ;
	}

	public int GetHashCode(PlaylistTrackHistory obj)
	{
		return obj.PlaylistId.GetHashCode()  ^ obj.TrackId.GetHashCode()  ^ obj.WrittenAt.GetHashCode() ;
	}
}
#endregion PlaylistTrackHistory

 #region TimeTable
/// <summary>
/// TimeTable 엔터티
/// </summary>
public partial class TimeTable : Entity<TimeTable>, IEntity
{
	public const string EntityTypeName = "TimeTable";

	public static void Copy(TimeTable source, TimeTable target)
	{
		target.Time = source.Time; 		
target.TimeNull = source.TimeNull; 
	}

	/// <summary>
	/// TimeTable 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override TimeTable Clone()
	{
		var clone = new TimeTable();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// TimeTable 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[Time]" + Time  + ", " + "[TimeNull]" + TimeNull ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", Time ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		Time = default;
	}
}

/// <summary>
/// TimeTable 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum TimeTableColumn
{
	Time ,
TimeNull 
}

/// <summary>
/// TimeTable 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;TimeTable&gt; 구현)
/// </summary>
public class TimeTableEqualityComparer : IEqualityComparer<TimeTable>
{
    #region singleton
    private static readonly Lazy<TimeTableEqualityComparer> _instance = new(() => new TimeTableEqualityComparer());

    public static TimeTableEqualityComparer Instance => _instance.Value;

    private TimeTableEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(TimeTable x, TimeTable y)
	{
		return x.Time == y.Time ;
	}

	public int GetHashCode(TimeTable obj)
	{
		return obj.Time.GetHashCode() ;
	}
}
#endregion TimeTable

 #region Track
/// <summary>
/// Track 엔터티
/// </summary>
public partial class Track : Entity<Track>, IEntity
{
	public const string EntityTypeName = "Track";

	public static void Copy(Track source, Track target)
	{
		target.TrackId = source.TrackId; 		
target.AlbumId = source.AlbumId; 		
target.BigIntCol = source.BigIntCol; 		
target.BigIntColNull = source.BigIntColNull; 		
target.BinaryCol = source.BinaryCol; 		
target.BinaryColNull = source.BinaryColNull; 		
target.BitCol = source.BitCol; 		
target.BitColNull = source.BitColNull; 		
target.CharCol = source.CharCol; 		
target.CharColNull = source.CharColNull; 		
target.DateCol = source.DateCol; 		
target.DateColNull = source.DateColNull; 		
target.DateOnlyCol = source.DateOnlyCol; 		
target.DateOnlyColNull = source.DateOnlyColNull; 		
target.DateTimeCol = source.DateTimeCol; 		
target.DateTimeColNull = source.DateTimeColNull; 		
target.DecimalCol = source.DecimalCol; 		
target.DecimalColNull = source.DecimalColNull; 		
target.FloatCol = source.FloatCol; 		
target.FloatColNull = source.FloatColNull; 		
target.GenreId = source.GenreId; 		
target.GuidCol = source.GuidCol; 		
target.GuidColNull = source.GuidColNull; 		
target.MediaTypeId = source.MediaTypeId; 		
target.Name = source.Name; 		
target.NcharCol = source.NcharCol; 		
target.NcharColNull = source.NcharColNull; 		
target.NvarCharCol = source.NvarCharCol; 		
target.NvarCharColNull = source.NvarCharColNull; 		
target.RealCol = source.RealCol; 		
target.RealColNull = source.RealColNull; 		
target.SmallDateTimeCol = source.SmallDateTimeCol; 		
target.SmallDateTimeColNull = source.SmallDateTimeColNull; 		
target.SmallIntCol = source.SmallIntCol; 		
target.SmallIntColNull = source.SmallIntColNull; 		
target.SmallMoneyCol = source.SmallMoneyCol; 		
target.SmallMoneyColNull = source.SmallMoneyColNull; 		
target.TimeCol = source.TimeCol; 		
target.TimeColNull = source.TimeColNull; 		
target.TimeOnlyCol = source.TimeOnlyCol; 		
target.TimeOnlyColNull = source.TimeOnlyColNull; 		
target.TimestampCol = source.TimestampCol; 		
target.TinyIntCol = source.TinyIntCol; 		
target.TinyIntColNull = source.TinyIntColNull; 		
target.VarBinaryCol = source.VarBinaryCol; 		
target.VarBinaryColNull = source.VarBinaryColNull; 		
target.VarCharCol = source.VarCharCol; 		
target.VarCharColNull = source.VarCharColNull; 
	}

	/// <summary>
	/// Track 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Track Clone()
	{
		var clone = new Track();

		Copy(this, clone);

		return clone;
	}
	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Track 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	[JsonIgnore]
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[TrackId]" + TrackId  + ", " + "[AlbumId]" + AlbumId  + ", " + "[BigIntCol]" + BigIntCol  + ", " + "[BigIntColNull]" + BigIntColNull  + ", " + "[BinaryCol]" + BinaryCol  + ", " + "[BinaryColNull]" + BinaryColNull  + ", " + "[BitCol]" + BitCol  + ", " + "[BitColNull]" + BitColNull  + ", " + "[CharCol]" + CharCol  + ", " + "[CharColNull]" + CharColNull  + ", " + "[DateCol]" + DateCol  + ", " + "[DateColNull]" + DateColNull  + ", " + "[DateOnlyCol]" + DateOnlyCol  + ", " + "[DateOnlyColNull]" + DateOnlyColNull  + ", " + "[DateTimeCol]" + DateTimeCol  + ", " + "[DateTimeColNull]" + DateTimeColNull  + ", " + "[DecimalCol]" + DecimalCol  + ", " + "[DecimalColNull]" + DecimalColNull  + ", " + "[FloatCol]" + FloatCol  + ", " + "[FloatColNull]" + FloatColNull  + ", " + "[GenreId]" + GenreId  + ", " + "[GuidCol]" + GuidCol  + ", " + "[GuidColNull]" + GuidColNull  + ", " + "[MediaTypeId]" + MediaTypeId  + ", " + "[Name]" + Name  + ", " + "[NcharCol]" + NcharCol  + ", " + "[NcharColNull]" + NcharColNull  + ", " + "[NvarCharCol]" + NvarCharCol  + ", " + "[NvarCharColNull]" + NvarCharColNull  + ", " + "[RealCol]" + RealCol  + ", " + "[RealColNull]" + RealColNull  + ", " + "[SmallDateTimeCol]" + SmallDateTimeCol  + ", " + "[SmallDateTimeColNull]" + SmallDateTimeColNull  + ", " + "[SmallIntCol]" + SmallIntCol  + ", " + "[SmallIntColNull]" + SmallIntColNull  + ", " + "[SmallMoneyCol]" + SmallMoneyCol  + ", " + "[SmallMoneyColNull]" + SmallMoneyColNull  + ", " + "[TimeCol]" + TimeCol  + ", " + "[TimeColNull]" + TimeColNull  + ", " + "[TimeOnlyCol]" + TimeOnlyCol  + ", " + "[TimeOnlyColNull]" + TimeOnlyColNull  + ", " + "[TimestampCol]" + TimestampCol  + ", " + "[TinyIntCol]" + TinyIntCol  + ", " + "[TinyIntColNull]" + TinyIntColNull  + ", " + "[VarBinaryCol]" + VarBinaryCol  + ", " + "[VarBinaryColNull]" + VarBinaryColNull  + ", " + "[VarCharCol]" + VarCharCol  + ", " + "[VarCharColNull]" + VarCharColNull ;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	[JsonIgnore]
	public override string PrimaryKeyValues
	{
		get { return string.Join(":", TrackId ); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}

    partial void ClearKeyValuesCore(ref bool handled);

	public override void ClearKeyValues()
	{
        bool handled = false;
		ClearKeyValuesCore(ref handled);
		if (handled)
			return;

		TrackId = default;
	}
}

/// <summary>
/// Track 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum TrackColumn
{
	TrackId ,
AlbumId ,
BigIntCol ,
BigIntColNull ,
BinaryCol ,
BinaryColNull ,
BitCol ,
BitColNull ,
CharCol ,
CharColNull ,
DateCol ,
DateColNull ,
DateOnlyCol ,
DateOnlyColNull ,
DateTimeCol ,
DateTimeColNull ,
DecimalCol ,
DecimalColNull ,
FloatCol ,
FloatColNull ,
GenreId ,
GuidCol ,
GuidColNull ,
MediaTypeId ,
Name ,
NcharCol ,
NcharColNull ,
NvarCharCol ,
NvarCharColNull ,
RealCol ,
RealColNull ,
SmallDateTimeCol ,
SmallDateTimeColNull ,
SmallIntCol ,
SmallIntColNull ,
SmallMoneyCol ,
SmallMoneyColNull ,
TimeCol ,
TimeColNull ,
TimeOnlyCol ,
TimeOnlyColNull ,
TimestampCol ,
TinyIntCol ,
TinyIntColNull ,
VarBinaryCol ,
VarBinaryColNull ,
VarCharCol ,
VarCharColNull 
}

/// <summary>
/// Track 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer&lt;Track&gt; 구현)
/// </summary>
public class TrackEqualityComparer : IEqualityComparer<Track>
{
    #region singleton
    private static readonly Lazy<TrackEqualityComparer> _instance = new(() => new TrackEqualityComparer());

    public static TrackEqualityComparer Instance => _instance.Value;

    private TrackEqualityComparer()
    {
    }
    #endregion singleton

	public bool Equals(Track x, Track y)
	{
		return x.TrackId == y.TrackId ;
	}

	public int GetHashCode(Track obj)
	{
		return obj.TrackId.GetHashCode() ;
	}
}
#endregion Track


#endregion Entities

#region EntityDao
 #region AlbumDao
/// <summary>
/// Album 데이터 클래스
/// </summary>
public partial class AlbumDao : EntityDao<Album>
{
	internal AlbumDao() {}

	protected override Expression<Func<Album, bool>> HasSameKey(Album other)
	{
        return x => x.AlbumId == other.AlbumId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="albumId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Album> GetByKey(int albumId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Album>().FirstOrDefaultAsync(x =>  x.AlbumId == albumId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="albumId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int albumId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Album>().CountAsync(x =>  x.AlbumId == albumId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="albumId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int albumId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(albumId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetByArtistId
    private IQueryable<Album> GetByArtistIdCore(DbContext context, int artistId)
    {
        return context.Set<Album>().Where(x => x.ArtistId == artistId);
    }

    public async Task<List<Album>> GetByArtistId(int artistId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByArtistIdCore(context, artistId).ToListAsync(ctk);
    }
    
    public async Task<Album[]> GetByArtistIdAsArray(int artistId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByArtistIdCore(context, artistId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<Album>> GetByArtistIdAsHastSet(int artistId, CancellationToken ctk = default)
    {
        try
        {
            await using var context = DbContextFactory.Create();

            var query = from x in context.Albums.Include(x => x.Tracks)
                select x;

            var list = await query.ToListAsync(ctk);
            Console.WriteLine($"finished with {list.Count}");
            return new HashSet<Album>();

            return await GetByArtistIdCore(context, artistId).ToHashSetAsync(ctk);
        }
        catch (Exception ex)
        {
            Console.WriteLine("cancelled");
            return new();
        }
    }
    
    public async Task<Dictionary<K, Album>> GetByArtistIdAsDictionary<K>(int artistId, Func<Album, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByArtistIdCore(context, artistId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByArtistIdAsDictionary<K, E>(int artistId, Func<Album, K> keySelector,Func<Album, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByArtistIdCore(context, artistId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="albumId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int albumId )
        => ExecuteDelete(x => x.AlbumId == albumId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="albumId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int albumId , Expression<Func<SetPropertyCalls<Album>, SetPropertyCalls<Album>>> setPropertyCalls)
        => ExecuteUpdate(x => x.AlbumId == albumId , setPropertyCalls);
}
#endregion AlbumDao

 #region ArtistDao
/// <summary>
/// Artist 데이터 클래스
/// </summary>
public partial class ArtistDao : EntityDao<Artist>
{
	internal ArtistDao() {}

	protected override Expression<Func<Artist, bool>> HasSameKey(Artist other)
	{
        return x => x.ArtistId == other.ArtistId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="artistId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Artist> GetByKey(int artistId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Artist>().FirstOrDefaultAsync(x =>  x.ArtistId == artistId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="artistId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int artistId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Artist>().CountAsync(x =>  x.ArtistId == artistId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="artistId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int artistId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(artistId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="artistId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int artistId )
        => ExecuteDelete(x => x.ArtistId == artistId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="artistId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int artistId , Expression<Func<SetPropertyCalls<Artist>, SetPropertyCalls<Artist>>> setPropertyCalls)
        => ExecuteUpdate(x => x.ArtistId == artistId , setPropertyCalls);
}
#endregion ArtistDao

 #region CodeDao
/// <summary>
/// Code 데이터 클래스
/// </summary>
public partial class CodeDao : EntityDao<Code>
{
	internal CodeDao() {}

	protected override Expression<Func<Code, bool>> HasSameKey(Code other)
	{
        return x => x.CodeId == other.CodeId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="codeId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Code> GetByKey(int codeId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Code>().FirstOrDefaultAsync(x =>  x.CodeId == codeId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="codeId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int codeId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Code>().CountAsync(x =>  x.CodeId == codeId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="codeId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int codeId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(codeId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetByCodeCategoryId
    private IQueryable<Code> GetByCodeCategoryIdCore(DbContext context, int codeCategoryId)
    {
        return context.Set<Code>().Where(x => x.CodeCategoryId == codeCategoryId);
    }

    public async Task<List<Code>> GetByCodeCategoryId(int codeCategoryId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCodeCategoryIdCore(context, codeCategoryId).ToListAsync(ctk);
    }
    
    public async Task<Code[]> GetByCodeCategoryIdAsArray(int codeCategoryId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCodeCategoryIdCore(context, codeCategoryId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<Code>> GetByCodeCategoryIdAsHastSet(int codeCategoryId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCodeCategoryIdCore(context, codeCategoryId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, Code>> GetByCodeCategoryIdAsDictionary<K>(int codeCategoryId, Func<Code, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCodeCategoryIdCore(context, codeCategoryId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByCodeCategoryIdAsDictionary<K, E>(int codeCategoryId, Func<Code, K> keySelector,Func<Code, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCodeCategoryIdCore(context, codeCategoryId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="codeId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int codeId )
        => ExecuteDelete(x => x.CodeId == codeId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="codeId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int codeId , Expression<Func<SetPropertyCalls<Code>, SetPropertyCalls<Code>>> setPropertyCalls)
        => ExecuteUpdate(x => x.CodeId == codeId , setPropertyCalls);
}
#endregion CodeDao

 #region CodeCategoryDao
/// <summary>
/// CodeCategory 데이터 클래스
/// </summary>
public partial class CodeCategoryDao : EntityDao<CodeCategory>
{
	internal CodeCategoryDao() {}

	protected override Expression<Func<CodeCategory, bool>> HasSameKey(CodeCategory other)
	{
        return x => x.CodeCategoryId == other.CodeCategoryId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="codeCategoryId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<CodeCategory> GetByKey(int codeCategoryId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<CodeCategory>().FirstOrDefaultAsync(x =>  x.CodeCategoryId == codeCategoryId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="codeCategoryId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int codeCategoryId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<CodeCategory>().CountAsync(x =>  x.CodeCategoryId == codeCategoryId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="codeCategoryId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int codeCategoryId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(codeCategoryId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="codeCategoryId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int codeCategoryId )
        => ExecuteDelete(x => x.CodeCategoryId == codeCategoryId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="codeCategoryId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int codeCategoryId , Expression<Func<SetPropertyCalls<CodeCategory>, SetPropertyCalls<CodeCategory>>> setPropertyCalls)
        => ExecuteUpdate(x => x.CodeCategoryId == codeCategoryId , setPropertyCalls);
}
#endregion CodeCategoryDao

 #region CustomerDao
/// <summary>
/// Customer 데이터 클래스
/// </summary>
public partial class CustomerDao : EntityDao<Customer>
{
	internal CustomerDao() {}

	protected override Expression<Func<Customer, bool>> HasSameKey(Customer other)
	{
        return x => x.CustomerId == other.CustomerId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="customerId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Customer> GetByKey(int customerId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Customer>().FirstOrDefaultAsync(x =>  x.CustomerId == customerId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="customerId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int customerId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Customer>().CountAsync(x =>  x.CustomerId == customerId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="customerId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int customerId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(customerId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetBySupportRepId
    private IQueryable<Customer> GetBySupportRepIdCore(DbContext context, int? supportRepId)
    {
        return context.Set<Customer>().Where(x => x.SupportRepId == supportRepId);
    }

    public async Task<List<Customer>> GetBySupportRepId(int? supportRepId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBySupportRepIdCore(context, supportRepId).ToListAsync(ctk);
    }
    
    public async Task<Customer[]> GetBySupportRepIdAsArray(int? supportRepId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBySupportRepIdCore(context, supportRepId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<Customer>> GetBySupportRepIdAsHastSet(int? supportRepId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBySupportRepIdCore(context, supportRepId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, Customer>> GetBySupportRepIdAsDictionary<K>(int? supportRepId, Func<Customer, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBySupportRepIdCore(context, supportRepId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetBySupportRepIdAsDictionary<K, E>(int? supportRepId, Func<Customer, K> keySelector,Func<Customer, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetBySupportRepIdCore(context, supportRepId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="customerId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int customerId )
        => ExecuteDelete(x => x.CustomerId == customerId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="customerId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int customerId , Expression<Func<SetPropertyCalls<Customer>, SetPropertyCalls<Customer>>> setPropertyCalls)
        => ExecuteUpdate(x => x.CustomerId == customerId , setPropertyCalls);
}
#endregion CustomerDao

 #region DateTableDao
/// <summary>
/// DateTable 데이터 클래스
/// </summary>
public partial class DateTableDao : EntityDao<DateTable>
{
	internal DateTableDao() {}

	protected override Expression<Func<DateTable, bool>> HasSameKey(DateTable other)
	{
        return x => x.Date == other.Date ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="date">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<DateTable> GetByKey(DateOnly date , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<DateTable>().FirstOrDefaultAsync(x =>  x.Date == date , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="date">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(DateOnly date , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<DateTable>().CountAsync(x =>  x.Date == date , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="date">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(DateOnly date , CancellationToken ctk = default)
	{
        var entity = await GetByKey(date , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="date">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(DateOnly date )
        => ExecuteDelete(x => x.Date == date );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="date">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(DateOnly date , Expression<Func<SetPropertyCalls<DateTable>, SetPropertyCalls<DateTable>>> setPropertyCalls)
        => ExecuteUpdate(x => x.Date == date , setPropertyCalls);
}
#endregion DateTableDao

 #region EmployeeDao
/// <summary>
/// Employee 데이터 클래스
/// </summary>
public partial class EmployeeDao : EntityDao<Employee>
{
	internal EmployeeDao() {}

	protected override Expression<Func<Employee, bool>> HasSameKey(Employee other)
	{
        return x => x.EmployeeId == other.EmployeeId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="employeeId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Employee> GetByKey(int employeeId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Employee>().FirstOrDefaultAsync(x =>  x.EmployeeId == employeeId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="employeeId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int employeeId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Employee>().CountAsync(x =>  x.EmployeeId == employeeId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="employeeId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int employeeId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(employeeId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetByReportsTo
    private IQueryable<Employee> GetByReportsToCore(DbContext context, int? reportsTo)
    {
        return context.Set<Employee>().Where(x => x.ReportsTo == reportsTo);
    }

    public async Task<List<Employee>> GetByReportsTo(int? reportsTo, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByReportsToCore(context, reportsTo).ToListAsync(ctk);
    }
    
    public async Task<Employee[]> GetByReportsToAsArray(int? reportsTo, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByReportsToCore(context, reportsTo).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<Employee>> GetByReportsToAsHastSet(int? reportsTo, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByReportsToCore(context, reportsTo).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, Employee>> GetByReportsToAsDictionary<K>(int? reportsTo, Func<Employee, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByReportsToCore(context, reportsTo).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByReportsToAsDictionary<K, E>(int? reportsTo, Func<Employee, K> keySelector,Func<Employee, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByReportsToCore(context, reportsTo).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="employeeId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int employeeId )
        => ExecuteDelete(x => x.EmployeeId == employeeId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="employeeId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int employeeId , Expression<Func<SetPropertyCalls<Employee>, SetPropertyCalls<Employee>>> setPropertyCalls)
        => ExecuteUpdate(x => x.EmployeeId == employeeId , setPropertyCalls);
}
#endregion EmployeeDao

 #region GenreDao
/// <summary>
/// Genre 데이터 클래스
/// </summary>
public partial class GenreDao : EntityDao<Genre>
{
	internal GenreDao() {}

	protected override Expression<Func<Genre, bool>> HasSameKey(Genre other)
	{
        return x => x.GenreId == other.GenreId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="genreId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Genre> GetByKey(int genreId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Genre>().FirstOrDefaultAsync(x =>  x.GenreId == genreId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="genreId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int genreId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Genre>().CountAsync(x =>  x.GenreId == genreId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="genreId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int genreId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(genreId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="genreId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int genreId )
        => ExecuteDelete(x => x.GenreId == genreId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="genreId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int genreId , Expression<Func<SetPropertyCalls<Genre>, SetPropertyCalls<Genre>>> setPropertyCalls)
        => ExecuteUpdate(x => x.GenreId == genreId , setPropertyCalls);
}
#endregion GenreDao

 #region InvoiceDao
/// <summary>
/// Invoice 데이터 클래스
/// </summary>
public partial class InvoiceDao : EntityDao<Invoice>
{
	internal InvoiceDao() {}

	protected override Expression<Func<Invoice, bool>> HasSameKey(Invoice other)
	{
        return x => x.InvoiceId == other.InvoiceId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="invoiceId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Invoice> GetByKey(int invoiceId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Invoice>().FirstOrDefaultAsync(x =>  x.InvoiceId == invoiceId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="invoiceId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int invoiceId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Invoice>().CountAsync(x =>  x.InvoiceId == invoiceId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="invoiceId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int invoiceId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(invoiceId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetByCustomerId
    private IQueryable<Invoice> GetByCustomerIdCore(DbContext context, int customerId)
    {
        return context.Set<Invoice>().Where(x => x.CustomerId == customerId);
    }

    public async Task<List<Invoice>> GetByCustomerId(int customerId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCustomerIdCore(context, customerId).ToListAsync(ctk);
    }
    
    public async Task<Invoice[]> GetByCustomerIdAsArray(int customerId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCustomerIdCore(context, customerId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<Invoice>> GetByCustomerIdAsHastSet(int customerId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCustomerIdCore(context, customerId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, Invoice>> GetByCustomerIdAsDictionary<K>(int customerId, Func<Invoice, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCustomerIdCore(context, customerId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByCustomerIdAsDictionary<K, E>(int customerId, Func<Invoice, K> keySelector,Func<Invoice, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByCustomerIdCore(context, customerId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="invoiceId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int invoiceId )
        => ExecuteDelete(x => x.InvoiceId == invoiceId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="invoiceId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int invoiceId , Expression<Func<SetPropertyCalls<Invoice>, SetPropertyCalls<Invoice>>> setPropertyCalls)
        => ExecuteUpdate(x => x.InvoiceId == invoiceId , setPropertyCalls);
}
#endregion InvoiceDao

 #region InvoiceLineDao
/// <summary>
/// InvoiceLine 데이터 클래스
/// </summary>
public partial class InvoiceLineDao : EntityDao<InvoiceLine>
{
	internal InvoiceLineDao() {}

	protected override Expression<Func<InvoiceLine, bool>> HasSameKey(InvoiceLine other)
	{
        return x => x.InvoiceLineId == other.InvoiceLineId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="invoiceLineId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<InvoiceLine> GetByKey(int invoiceLineId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<InvoiceLine>().FirstOrDefaultAsync(x =>  x.InvoiceLineId == invoiceLineId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="invoiceLineId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int invoiceLineId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<InvoiceLine>().CountAsync(x =>  x.InvoiceLineId == invoiceLineId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="invoiceLineId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int invoiceLineId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(invoiceLineId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetByInvoiceId
    private IQueryable<InvoiceLine> GetByInvoiceIdCore(DbContext context, int invoiceId)
    {
        return context.Set<InvoiceLine>().Where(x => x.InvoiceId == invoiceId);
    }

    public async Task<List<InvoiceLine>> GetByInvoiceId(int invoiceId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByInvoiceIdCore(context, invoiceId).ToListAsync(ctk);
    }
    
    public async Task<InvoiceLine[]> GetByInvoiceIdAsArray(int invoiceId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByInvoiceIdCore(context, invoiceId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<InvoiceLine>> GetByInvoiceIdAsHastSet(int invoiceId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByInvoiceIdCore(context, invoiceId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, InvoiceLine>> GetByInvoiceIdAsDictionary<K>(int invoiceId, Func<InvoiceLine, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByInvoiceIdCore(context, invoiceId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByInvoiceIdAsDictionary<K, E>(int invoiceId, Func<InvoiceLine, K> keySelector,Func<InvoiceLine, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByInvoiceIdCore(context, invoiceId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="invoiceLineId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int invoiceLineId )
        => ExecuteDelete(x => x.InvoiceLineId == invoiceLineId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="invoiceLineId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int invoiceLineId , Expression<Func<SetPropertyCalls<InvoiceLine>, SetPropertyCalls<InvoiceLine>>> setPropertyCalls)
        => ExecuteUpdate(x => x.InvoiceLineId == invoiceLineId , setPropertyCalls);
}
#endregion InvoiceLineDao

 #region MediaTypeDao
/// <summary>
/// MediaType 데이터 클래스
/// </summary>
public partial class MediaTypeDao : EntityDao<MediaType>
{
	internal MediaTypeDao() {}

	protected override Expression<Func<MediaType, bool>> HasSameKey(MediaType other)
	{
        return x => x.MediaTypeId == other.MediaTypeId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="mediaTypeId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<MediaType> GetByKey(int mediaTypeId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<MediaType>().FirstOrDefaultAsync(x =>  x.MediaTypeId == mediaTypeId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="mediaTypeId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int mediaTypeId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<MediaType>().CountAsync(x =>  x.MediaTypeId == mediaTypeId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="mediaTypeId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int mediaTypeId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(mediaTypeId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="mediaTypeId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int mediaTypeId )
        => ExecuteDelete(x => x.MediaTypeId == mediaTypeId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="mediaTypeId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int mediaTypeId , Expression<Func<SetPropertyCalls<MediaType>, SetPropertyCalls<MediaType>>> setPropertyCalls)
        => ExecuteUpdate(x => x.MediaTypeId == mediaTypeId , setPropertyCalls);
}
#endregion MediaTypeDao

 #region PlaylistDao
/// <summary>
/// Playlist 데이터 클래스
/// </summary>
public partial class PlaylistDao : EntityDao<Playlist>
{
	internal PlaylistDao() {}

	protected override Expression<Func<Playlist, bool>> HasSameKey(Playlist other)
	{
        return x => x.PlaylistId == other.PlaylistId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Playlist> GetByKey(int playlistId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Playlist>().FirstOrDefaultAsync(x =>  x.PlaylistId == playlistId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int playlistId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Playlist>().CountAsync(x =>  x.PlaylistId == playlistId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="playlistId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int playlistId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(playlistId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int playlistId )
        => ExecuteDelete(x => x.PlaylistId == playlistId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int playlistId , Expression<Func<SetPropertyCalls<Playlist>, SetPropertyCalls<Playlist>>> setPropertyCalls)
        => ExecuteUpdate(x => x.PlaylistId == playlistId , setPropertyCalls);
}
#endregion PlaylistDao

 #region PlaylistTrackDao
/// <summary>
/// PlaylistTrack 데이터 클래스
/// </summary>
public partial class PlaylistTrackDao : EntityDao<PlaylistTrack>
{
	internal PlaylistTrackDao() {}

	protected override Expression<Func<PlaylistTrack, bool>> HasSameKey(PlaylistTrack other)
	{
        return x => x.PlaylistId == other.PlaylistId  &&x.TrackId == other.TrackId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
/// <param name="trackId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<PlaylistTrack> GetByKey(int playlistId , int trackId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<PlaylistTrack>().FirstOrDefaultAsync(x =>  x.PlaylistId == playlistId  &&  x.TrackId == trackId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
/// <param name="trackId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int playlistId , int trackId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<PlaylistTrack>().CountAsync(x =>  x.PlaylistId == playlistId  &&  x.TrackId == trackId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int playlistId , int trackId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(playlistId , trackId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetByPlaylistId
    private IQueryable<PlaylistTrack> GetByPlaylistIdCore(DbContext context, int playlistId)
    {
        return context.Set<PlaylistTrack>().Where(x => x.PlaylistId == playlistId);
    }

    public async Task<List<PlaylistTrack>> GetByPlaylistId(int playlistId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToListAsync(ctk);
    }
    
    public async Task<PlaylistTrack[]> GetByPlaylistIdAsArray(int playlistId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<PlaylistTrack>> GetByPlaylistIdAsHastSet(int playlistId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, PlaylistTrack>> GetByPlaylistIdAsDictionary<K>(int playlistId, Func<PlaylistTrack, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByPlaylistIdAsDictionary<K, E>(int playlistId, Func<PlaylistTrack, K> keySelector,Func<PlaylistTrack, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    
	#region GetByTrackId
    private IQueryable<PlaylistTrack> GetByTrackIdCore(DbContext context, int trackId)
    {
        return context.Set<PlaylistTrack>().Where(x => x.TrackId == trackId);
    }

    public async Task<List<PlaylistTrack>> GetByTrackId(int trackId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToListAsync(ctk);
    }
    
    public async Task<PlaylistTrack[]> GetByTrackIdAsArray(int trackId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<PlaylistTrack>> GetByTrackIdAsHastSet(int trackId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, PlaylistTrack>> GetByTrackIdAsDictionary<K>(int trackId, Func<PlaylistTrack, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByTrackIdAsDictionary<K, E>(int trackId, Func<PlaylistTrack, K> keySelector,Func<PlaylistTrack, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int playlistId , int trackId )
        => ExecuteDelete(x => x.PlaylistId == playlistId && x.TrackId == trackId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int playlistId , int trackId , Expression<Func<SetPropertyCalls<PlaylistTrack>, SetPropertyCalls<PlaylistTrack>>> setPropertyCalls)
        => ExecuteUpdate(x => x.PlaylistId == playlistId && x.TrackId == trackId , setPropertyCalls);
}
#endregion PlaylistTrackDao

 #region PlaylistTrackHistoryDao
/// <summary>
/// PlaylistTrackHistory 데이터 클래스
/// </summary>
public partial class PlaylistTrackHistoryDao : EntityDao<PlaylistTrackHistory>
{
	internal PlaylistTrackHistoryDao() {}

	protected override Expression<Func<PlaylistTrackHistory, bool>> HasSameKey(PlaylistTrackHistory other)
	{
        return x => x.PlaylistId == other.PlaylistId  &&x.TrackId == other.TrackId  &&x.WrittenAt == other.WrittenAt ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
/// <param name="trackId">기본키</param>
/// <param name="writtenAt">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<PlaylistTrackHistory> GetByKey(int playlistId , int trackId , DateTime writtenAt , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<PlaylistTrackHistory>().FirstOrDefaultAsync(x =>  x.PlaylistId == playlistId  &&  x.TrackId == trackId  &&  x.WrittenAt == writtenAt , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="playlistId">기본키</param>
/// <param name="trackId">기본키</param>
/// <param name="writtenAt">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int playlistId , int trackId , DateTime writtenAt , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<PlaylistTrackHistory>().CountAsync(x =>  x.PlaylistId == playlistId  &&  x.TrackId == trackId  &&  x.WrittenAt == writtenAt , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> /// <param name="writtenAt">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int playlistId , int trackId , DateTime writtenAt , CancellationToken ctk = default)
	{
        var entity = await GetByKey(playlistId , trackId , writtenAt , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetByPlaylistId
    private IQueryable<PlaylistTrackHistory> GetByPlaylistIdCore(DbContext context, int playlistId)
    {
        return context.Set<PlaylistTrackHistory>().Where(x => x.PlaylistId == playlistId);
    }

    public async Task<List<PlaylistTrackHistory>> GetByPlaylistId(int playlistId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToListAsync(ctk);
    }
    
    public async Task<PlaylistTrackHistory[]> GetByPlaylistIdAsArray(int playlistId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<PlaylistTrackHistory>> GetByPlaylistIdAsHastSet(int playlistId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, PlaylistTrackHistory>> GetByPlaylistIdAsDictionary<K>(int playlistId, Func<PlaylistTrackHistory, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByPlaylistIdAsDictionary<K, E>(int playlistId, Func<PlaylistTrackHistory, K> keySelector,Func<PlaylistTrackHistory, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByPlaylistIdCore(context, playlistId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    
	#region GetByTrackId
    private IQueryable<PlaylistTrackHistory> GetByTrackIdCore(DbContext context, int trackId)
    {
        return context.Set<PlaylistTrackHistory>().Where(x => x.TrackId == trackId);
    }

    public async Task<List<PlaylistTrackHistory>> GetByTrackId(int trackId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToListAsync(ctk);
    }
    
    public async Task<PlaylistTrackHistory[]> GetByTrackIdAsArray(int trackId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<PlaylistTrackHistory>> GetByTrackIdAsHastSet(int trackId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, PlaylistTrackHistory>> GetByTrackIdAsDictionary<K>(int trackId, Func<PlaylistTrackHistory, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByTrackIdAsDictionary<K, E>(int trackId, Func<PlaylistTrackHistory, K> keySelector,Func<PlaylistTrackHistory, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByTrackIdCore(context, trackId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> /// <param name="writtenAt">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int playlistId , int trackId , DateTime writtenAt )
        => ExecuteDelete(x => x.PlaylistId == playlistId && x.TrackId == trackId && x.WrittenAt == writtenAt );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="playlistId">기본키</param> /// <param name="trackId">기본키</param> /// <param name="writtenAt">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int playlistId , int trackId , DateTime writtenAt , Expression<Func<SetPropertyCalls<PlaylistTrackHistory>, SetPropertyCalls<PlaylistTrackHistory>>> setPropertyCalls)
        => ExecuteUpdate(x => x.PlaylistId == playlistId && x.TrackId == trackId && x.WrittenAt == writtenAt , setPropertyCalls);
}
#endregion PlaylistTrackHistoryDao

 #region TimeTableDao
/// <summary>
/// TimeTable 데이터 클래스
/// </summary>
public partial class TimeTableDao : EntityDao<TimeTable>
{
	internal TimeTableDao() {}

	protected override Expression<Func<TimeTable, bool>> HasSameKey(TimeTable other)
	{
        return x => x.Time == other.Time ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="time">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<TimeTable> GetByKey(TimeOnly time , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<TimeTable>().FirstOrDefaultAsync(x =>  x.Time == time , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="time">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(TimeOnly time , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<TimeTable>().CountAsync(x =>  x.Time == time , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="time">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(TimeOnly time , CancellationToken ctk = default)
	{
        var entity = await GetByKey(time , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="time">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(TimeOnly time )
        => ExecuteDelete(x => x.Time == time );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="time">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(TimeOnly time , Expression<Func<SetPropertyCalls<TimeTable>, SetPropertyCalls<TimeTable>>> setPropertyCalls)
        => ExecuteUpdate(x => x.Time == time , setPropertyCalls);
}
#endregion TimeTableDao

 #region TrackDao
/// <summary>
/// Track 데이터 클래스
/// </summary>
public partial class TrackDao : EntityDao<Track>
{
	internal TrackDao() {}

	protected override Expression<Func<Track, bool>> HasSameKey(Track other)
	{
        return x => x.TrackId == other.TrackId ;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
	/// <param name="trackId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public async Task<Track> GetByKey(int trackId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

        return await context.Set<Track>().FirstOrDefaultAsync(x =>  x.TrackId == trackId , ctk);
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
	/// <param name="trackId">기본키</param>
	/// <returns>존재 여부</returns>
    public async Task<bool> ExistsByKey(int trackId , CancellationToken ctk = default)
	{
        await using var context = DbContextFactory.Create();

		return await context.Set<Track>().CountAsync(x =>  x.TrackId == trackId , ctk) > 0;
	}

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
	/// <param name="trackId">기본키</param> 
	/// <returns>삭제된 엔터티의 갯수</returns>
    public async Task<int> DeleteByKey(int trackId , CancellationToken ctk = default)
	{
        var entity = await GetByKey(trackId , ctk);

        if (entity == null)
            return 0;

        return await Delete(entity, ctk);
	}
	
	
	#region GetByAlbumId
    private IQueryable<Track> GetByAlbumIdCore(DbContext context, int? albumId)
    {
        return context.Set<Track>().Where(x => x.AlbumId == albumId);
    }

    public async Task<List<Track>> GetByAlbumId(int? albumId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByAlbumIdCore(context, albumId).ToListAsync(ctk);
    }
    
    public async Task<Track[]> GetByAlbumIdAsArray(int? albumId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByAlbumIdCore(context, albumId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<Track>> GetByAlbumIdAsHastSet(int? albumId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByAlbumIdCore(context, albumId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, Track>> GetByAlbumIdAsDictionary<K>(int? albumId, Func<Track, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByAlbumIdCore(context, albumId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByAlbumIdAsDictionary<K, E>(int? albumId, Func<Track, K> keySelector,Func<Track, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByAlbumIdCore(context, albumId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    
	#region GetByGenreId
    private IQueryable<Track> GetByGenreIdCore(DbContext context, int genreId)
    {
        return context.Set<Track>().Where(x => x.GenreId == genreId);
    }

    public async Task<List<Track>> GetByGenreId(int genreId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByGenreIdCore(context, genreId).ToListAsync(ctk);
    }
    
    public async Task<Track[]> GetByGenreIdAsArray(int genreId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByGenreIdCore(context, genreId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<Track>> GetByGenreIdAsHastSet(int genreId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByGenreIdCore(context, genreId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, Track>> GetByGenreIdAsDictionary<K>(int genreId, Func<Track, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByGenreIdCore(context, genreId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByGenreIdAsDictionary<K, E>(int genreId, Func<Track, K> keySelector,Func<Track, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByGenreIdCore(context, genreId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    
	#region GetByMediaTypeId
    private IQueryable<Track> GetByMediaTypeIdCore(DbContext context, int mediaTypeId)
    {
        return context.Set<Track>().Where(x => x.MediaTypeId == mediaTypeId);
    }

    public async Task<List<Track>> GetByMediaTypeId(int mediaTypeId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByMediaTypeIdCore(context, mediaTypeId).ToListAsync(ctk);
    }
    
    public async Task<Track[]> GetByMediaTypeIdAsArray(int mediaTypeId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByMediaTypeIdCore(context, mediaTypeId).ToArrayAsync(ctk);
    }
    
    public async Task<HashSet<Track>> GetByMediaTypeIdAsHastSet(int mediaTypeId, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByMediaTypeIdCore(context, mediaTypeId).ToHashSetAsync(ctk);
    }
    
    public async Task<Dictionary<K, Track>> GetByMediaTypeIdAsDictionary<K>(int mediaTypeId, Func<Track, K> keySelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByMediaTypeIdCore(context, mediaTypeId).ToDictionaryAsync(keySelector, ctk);
    }
    
    public async Task<Dictionary<K, E>> GetByMediaTypeIdAsDictionary<K, E>(int mediaTypeId, Func<Track, K> keySelector,Func<Track, E> elementSelector, CancellationToken ctk = default)
    {
        await using var context = DbContextFactory.Create();

        return await GetByMediaTypeIdCore(context, mediaTypeId).ToDictionaryAsync(keySelector, elementSelector, ctk);
    }
    #endregion
    

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 삭제한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="trackId">기본키</param> 
    /// <returns></returns>
    public Task<int> ExecuteDeleteByKey(int trackId )
        => ExecuteDelete(x => x.TrackId == trackId );

    /// <summary>
    /// 기본키가 일치하는 항목 한 건을 업데이트한다. OnSaving과 OnSaved 부분 메서드를 호출하지 않음.
    /// </summary>
    /// <param name="trackId">기본키</param> 
    /// <param name="setPropertyCalls">변경할 속성. 엔티티의 다른 속성도 참조 가능. ex)Dao.User.ExecuteUpdate(user.UserId, p => p.SetProperty(x => x.LastLoggedAt, DateTime.Now));</param>
    /// <returns></returns>
    public Task<int> ExecuteUpdateByKey(int trackId , Expression<Func<SetPropertyCalls<Track>, SetPropertyCalls<Track>>> setPropertyCalls)
        => ExecuteUpdate(x => x.TrackId == trackId , setPropertyCalls);
}
#endregion TrackDao


#endregion EntityDao

#region Dao
/// <summary>
/// 각 엔터티 데이터 객체의 모음
/// </summary>
public partial class Dao : DaoBase
{
	static Dao()
	{
		 Album = new AlbumDao(); 
 Artist = new ArtistDao(); 
 Code = new CodeDao(); 
 CodeCategory = new CodeCategoryDao(); 
 Customer = new CustomerDao(); 
 DateTable = new DateTableDao(); 
 Employee = new EmployeeDao(); 
 Genre = new GenreDao(); 
 Invoice = new InvoiceDao(); 
 InvoiceLine = new InvoiceLineDao(); 
 MediaType = new MediaTypeDao(); 
 Playlist = new PlaylistDao(); 
 PlaylistTrack = new PlaylistTrackDao(); 
 PlaylistTrackHistory = new PlaylistTrackHistoryDao(); 
 TimeTable = new TimeTableDao(); 
 Track = new TrackDao(); 

	}

	#region Data objects
	 public static AlbumDao Album { get; } 
 public static ArtistDao Artist { get; } 
 public static CodeDao Code { get; } 
 public static CodeCategoryDao CodeCategory { get; } 
 public static CustomerDao Customer { get; } 
 public static DateTableDao DateTable { get; } 
 public static EmployeeDao Employee { get; } 
 public static GenreDao Genre { get; } 
 public static InvoiceDao Invoice { get; } 
 public static InvoiceLineDao InvoiceLine { get; } 
 public static MediaTypeDao MediaType { get; } 
 public static PlaylistDao Playlist { get; } 
 public static PlaylistTrackDao PlaylistTrack { get; } 
 public static PlaylistTrackHistoryDao PlaylistTrackHistory { get; } 
 public static TimeTableDao TimeTable { get; } 
 public static TrackDao Track { get; } 

	#endregion

	public static EntityDao<T> Get<T>() where T : Entity<T>, new()
    {
        object result = typeof(T).Name switch
        {
             "Album" => Album, 
 "Artist" => Artist, 
 "Code" => Code, 
 "CodeCategory" => CodeCategory, 
 "Customer" => Customer, 
 "DateTable" => DateTable, 
 "Employee" => Employee, 
 "Genre" => Genre, 
 "Invoice" => Invoice, 
 "InvoiceLine" => InvoiceLine, 
 "MediaType" => MediaType, 
 "Playlist" => Playlist, 
 "PlaylistTrack" => PlaylistTrack, 
 "PlaylistTrackHistory" => PlaylistTrackHistory, 
 "TimeTable" => TimeTable, 
 "Track" => Track, 

			_ => throw new NotImplementedException("Dao.Get")
        };

        return result as EntityDao<T>;
    }
}
#endregion